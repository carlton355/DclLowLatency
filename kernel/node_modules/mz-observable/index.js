"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A class serves as a medium between the observable and its observers
 * @public
 */
class ObserverEventState {
    /**
     * Create a new EventState
     * @param mask - defines the mask associated with this state
     * @param skipNextObservers - defines a flag which will instruct the observable to skip following observers when set to true
     * @param target - defines the original target of the state
     * @param currentTarget - defines the current target of the state
     */
    constructor(mask, skipNextObservers = false, target, currentTarget) {
        this.initalize(mask, skipNextObservers, target, currentTarget);
    }
    /**
     * Initialize the current event state
     * @param mask - defines the mask associated with this state
     * @param skipNextObservers - defines a flag which will instruct the observable to skip following observers when set to true
     * @param target - defines the original target of the state
     * @param currentTarget - defines the current target of the state
     * @returns the current event state
     */
    initalize(mask, skipNextObservers = false, target, currentTarget) {
        this.mask = mask;
        this.skipNextObservers = skipNextObservers;
        this.target = target;
        this.currentTarget = currentTarget;
        return this;
    }
}
exports.ObserverEventState = ObserverEventState;
/**
 * Represent an Observer registered to a given Observable object.
 * @public
 */
class Observer {
    /**
     * Creates a new observer
     * @param callback - defines the callback to call when the observer is notified
     * @param mask - defines the mask of the observer (used to filter notifications)
     * @param scope - defines the current scope used to restore the JS context
     */
    constructor(
    /**
     * Defines the callback to call when the observer is notified
     */
    callback, 
    /**
     * Defines the mask of the observer (used to filter notifications)
     */
    mask, 
    /**
     * Defines the current scope used to restore the JS context
     */
    scope = null) {
        this.callback = callback;
        this.mask = mask;
        this.scope = scope;
        /**
         * Gets or sets a property defining that the observer as to be unregistered after the next notification
         */
        this.unregisterOnNextCall = false;
        /** For internal usage */
        this._willBeUnregistered = false;
    }
}
exports.Observer = Observer;
/**
 * Represent a list of observers registered to multiple Observables object.
 * @public
 */
class MultiObserver {
    constructor() {
        this._observers = null;
        this._observables = null;
    }
    /**
     * Raise a callback when one of the observable will notify
     * @param observables - defines a list of observables to watch
     * @param callback - defines the callback to call on notification
     * @param mask - defines the mask used to filter notifications
     * @param scope - defines the current scope used to restore the JS context
     * @returns the new MultiObserver
     */
    static Watch(observables, callback, mask = -1, scope = null) {
        let result = new MultiObserver();
        result._observers = new Array();
        result._observables = observables;
        for (let observable of observables) {
            let observer = observable.add(callback, mask, false, scope);
            if (observer) {
                result._observers.push(observer);
            }
        }
        return result;
    }
    /**
     * Release associated resources
     */
    dispose() {
        if (this._observers && this._observables) {
            for (let index = 0; index < this._observers.length; index++) {
                this._observables[index].remove(this._observers[index]);
            }
        }
        this._observers = null;
        this._observables = null;
    }
}
exports.MultiObserver = MultiObserver;
/**
 * The Observable class is a simple implementation of the Observable pattern.
 *
 * There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.
 * This enable a more fine grained execution without having to rely on multiple different Observable objects.
 * For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).
 * A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.
 *
 * @public
 */
class Observable {
    /**
     * Creates a new observable
     * @param onObserverAdded - defines a callback to call when a new observer is added
     */
    constructor(onObserverAdded) {
        this._observers = new Array();
        this._onObserverAdded = null;
        this._eventState = new ObserverEventState(0);
        if (onObserverAdded) {
            this._onObserverAdded = onObserverAdded;
        }
    }
    /**
     * Create a new Observer with the specified callback
     * @param callback - the callback that will be executed for that Observer
     * @param mask - the mask used to filter observers
     * @param insertFirst - if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.
     * @param scope - optional scope for the callback to be called from
     * @param unregisterOnFirstCall - defines if the observer as to be unregistered after the next notification
     * @returns the new observer created for the callback
     */
    add(callback, mask = -1, insertFirst = false, scope = null, unregisterOnFirstCall = false) {
        if (!callback) {
            return null;
        }
        let observer = new Observer(callback, mask, scope);
        observer.unregisterOnNextCall = unregisterOnFirstCall;
        if (insertFirst) {
            this._observers.unshift(observer);
        }
        else {
            this._observers.push(observer);
        }
        if (this._onObserverAdded) {
            this._onObserverAdded(observer);
        }
        return observer;
    }
    /**
     * Create a new Observer with the specified callback and unregisters after the next notification
     * @param callback - the callback that will be executed for that Observer
     * @returns the new observer created for the callback
     */
    addOnce(callback) {
        return this.add(callback, undefined, undefined, undefined, true);
    }
    /**
     * Remove an Observer from the Observable object
     * @param observer - the instance of the Observer to remove
     * @returns false if it doesn't belong to this Observable
     */
    remove(observer) {
        if (!observer) {
            return false;
        }
        let index = this._observers.indexOf(observer);
        if (index !== -1) {
            this._deferUnregister(observer);
            return true;
        }
        return false;
    }
    /**
     * Remove a callback from the Observable object
     * @param callback - the callback to remove
     * @param scope - optional scope. If used only the callbacks with this scope will be removed
     * @returns false if it doesn't belong to this Observable
     */
    removeCallback(callback, scope) {
        for (let index = 0; index < this._observers.length; index++) {
            if (this._observers[index].callback === callback && (!scope || scope === this._observers[index].scope)) {
                this._deferUnregister(this._observers[index]);
                return true;
            }
        }
        return false;
    }
    /**
     * Notify all Observers by calling their respective callback with the given data
     * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute
     * @param eventData - defines the data to send to all observers
     * @param mask - defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)
     * @param target - defines the original target of the state
     * @param currentTarget - defines the current target of the state
     * @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)
     */
    notifyObservers(eventData, mask = -1, target, currentTarget) {
        if (!this._observers.length) {
            return true;
        }
        let state = this._eventState;
        state.mask = mask;
        state.target = target;
        state.currentTarget = currentTarget;
        state.skipNextObservers = false;
        state.lastReturnValue = eventData;
        for (let obs of this._observers) {
            if (obs._willBeUnregistered) {
                continue;
            }
            if (obs.mask & mask) {
                if (obs.scope) {
                    state.lastReturnValue = obs.callback.apply(obs.scope, [eventData, state]);
                }
                else {
                    state.lastReturnValue = obs.callback(eventData, state);
                }
                if (obs.unregisterOnNextCall) {
                    this._deferUnregister(obs);
                }
            }
            if (state.skipNextObservers) {
                return false;
            }
        }
        return true;
    }
    /**
     * Calling this will execute each callback, expecting it to be a promise or return a value.
     * If at any point in the chain one function fails, the promise will fail and the execution will not continue.
     * This is useful when a chain of events (sometimes async events) is needed to initialize a certain object
     * and it is crucial that all callbacks will be executed.
     * The order of the callbacks is kept, callbacks are not executed parallel.
     *
     * @param eventData - The data to be sent to each callback
     * @param mask - is used to filter observers defaults to -1
     * @param target - defines the callback target (see EventState)
     * @param currentTarget - defines he current object in the bubbling phase
     * @returns will return a Promise than resolves when all callbacks executed successfully.
     */
    notifyObserversWithPromise(eventData, mask = -1, target, currentTarget) {
        // create an empty promise
        let p = Promise.resolve(eventData);
        // no observers? return this promise.
        if (!this._observers.length) {
            return p;
        }
        let state = this._eventState;
        state.mask = mask;
        state.target = target;
        state.currentTarget = currentTarget;
        state.skipNextObservers = false;
        // execute one callback after another (not using Promise.all, the order is important)
        this._observers.forEach(obs => {
            if (state.skipNextObservers) {
                return;
            }
            if (obs._willBeUnregistered) {
                return;
            }
            if (obs.mask & mask) {
                if (obs.scope) {
                    p = p.then(lastReturnedValue => {
                        state.lastReturnValue = lastReturnedValue;
                        return obs.callback.apply(obs.scope, [eventData, state]);
                    });
                }
                else {
                    p = p.then(lastReturnedValue => {
                        state.lastReturnValue = lastReturnedValue;
                        return obs.callback(eventData, state);
                    });
                }
                if (obs.unregisterOnNextCall) {
                    this._deferUnregister(obs);
                }
            }
        });
        // return the eventData
        return p.then(() => {
            return eventData;
        });
    }
    /**
     * Notify a specific observer
     * @param observer - defines the observer to notify
     * @param eventData - defines the data to be sent to each callback
     * @param mask - is used to filter observers defaults to -1
     */
    notifyObserver(observer, eventData, mask = -1) {
        let state = this._eventState;
        state.mask = mask;
        state.skipNextObservers = false;
        observer.callback(eventData, state);
    }
    /**
     * Gets a boolean indicating if the observable has at least one observer
     * @returns true is the Observable has at least one Observer registered
     */
    hasObservers() {
        return this._observers.length > 0;
    }
    /**
     * Clear the list of observers
     */
    clear() {
        this._observers = new Array();
        this._onObserverAdded = null;
    }
    /**
     * Clone the current observable
     * @returns a new observable
     */
    clone() {
        let result = new Observable();
        result._observers = this._observers.slice(0);
        return result;
    }
    /**
     * Does this observable handles observer registered with a given mask
     * @param mask - defines the mask to be tested
     * @returns whether or not one observer registered with the given mask is handeled
     */
    hasSpecificMask(mask = -1) {
        for (let obs of this._observers) {
            if (obs.mask & mask || obs.mask === mask) {
                return true;
            }
        }
        return false;
    }
    _deferUnregister(observer) {
        observer.unregisterOnNextCall = false;
        observer._willBeUnregistered = true;
        Promise.resolve().then(() => this._remove(observer));
    }
    // This should only be called when not iterating over _observers to avoid callback skipping.
    // Removes an observer from the _observer Array.
    _remove(observer) {
        if (!observer) {
            return false;
        }
        let index = this._observers.indexOf(observer);
        if (index !== -1) {
            this._observers.splice(index, 1);
            return true;
        }
        return false;
    }
}
exports.Observable = Observable;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOzs7R0FHRztBQUNILE1BQWEsa0JBQWtCO0lBMkI3Qjs7Ozs7O09BTUc7SUFDSCxZQUFZLElBQVksRUFBRSxpQkFBaUIsR0FBRyxLQUFLLEVBQUUsTUFBWSxFQUFFLGFBQW1CO1FBQ3BGLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sRUFBRSxhQUFhLENBQUMsQ0FBQztJQUNqRSxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLFNBQVMsQ0FBQyxJQUFZLEVBQUUsaUJBQWlCLEdBQUcsS0FBSyxFQUFFLE1BQVksRUFBRSxhQUFtQjtRQUN6RixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsaUJBQWlCLEdBQUcsaUJBQWlCLENBQUM7UUFDM0MsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7UUFDbkMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0NBQ0Y7QUFyREQsZ0RBcURDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBYSxRQUFRO0lBU25COzs7OztPQUtHO0lBQ0g7SUFDRTs7T0FFRztJQUNJLFFBQWdFO0lBQ3ZFOztPQUVHO0lBQ0ksSUFBWTtJQUNuQjs7T0FFRztJQUNJLFFBQWEsSUFBSTtRQVJqQixhQUFRLEdBQVIsUUFBUSxDQUF3RDtRQUloRSxTQUFJLEdBQUosSUFBSSxDQUFRO1FBSVosVUFBSyxHQUFMLEtBQUssQ0FBWTtRQTFCMUI7O1dBRUc7UUFDSSx5QkFBb0IsR0FBRyxLQUFLLENBQUM7UUFFcEMseUJBQXlCO1FBQ2xCLHdCQUFtQixHQUFHLEtBQUssQ0FBQztJQXFCaEMsQ0FBQztDQUNMO0FBN0JELDRCQTZCQztBQUVEOzs7R0FHRztBQUNILE1BQWEsYUFBYTtJQUExQjtR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WUFDL0IsSUFBSSxHQUFHLENBQUMsSUFBSSxHQUFHLElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLElBQUksRUFBRTtnQkFDeEMsT0FBTyxJQUFJLENBQUM7YUFDYjtTQUNGO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRU8sZ0JBQWdCLENBQUMsUUFBcUI7UUFDNUMsUUFBUSxDQUFDLG9CQUFvQixHQUFHLEtBQUssQ0FBQztRQUN0QyxRQUFRLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDO1FBQ3BDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCw0RkFBNEY7SUFDNUYsZ0RBQWdEO0lBQ3hDLE9BQU8sQ0FBQyxRQUE0QjtRQUMxQyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2IsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTlDLElBQUksS0FBSyxLQUFLLENBQUMsQ0FBQyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNqQyxPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUEzUkQsZ0NBMlJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGNsYXNzIHNlcnZlcyBhcyBhIG1lZGl1bSBiZXR3ZWVuIHRoZSBvYnNlcnZhYmxlIGFuZCBpdHMgb2JzZXJ2ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBPYnNlcnZlckV2ZW50U3RhdGUge1xuICAvKipcbiAgICogQW4gT2JzZXJ2ZXIgY2FuIHNldCB0aGlzIHByb3BlcnR5IHRvIHRydWUgdG8gcHJldmVudCBzdWJzZXF1ZW50IG9ic2VydmVycyBvZiBiZWluZyBub3RpZmllZFxuICAgKi9cbiAgcHVibGljIHNraXBOZXh0T2JzZXJ2ZXJzITogYm9vbGVhbjtcblxuICAvKipcbiAgICogR2V0IHRoZSBtYXNrIHZhbHVlIHRoYXQgd2VyZSB1c2VkIHRvIHRyaWdnZXIgdGhlIGV2ZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBFdmVudFN0YXRlIG9iamVjdFxuICAgKi9cbiAgcHVibGljIG1hc2shOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdGhhdCBvcmlnaW5hbGx5IG5vdGlmaWVkIHRoZSBldmVudFxuICAgKi9cbiAgcHVibGljIHRhcmdldD86IGFueTtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgb2JqZWN0IGluIHRoZSBidWJibGluZyBwaGFzZVxuICAgKi9cbiAgcHVibGljIGN1cnJlbnRUYXJnZXQ/OiBhbnk7XG5cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBsYXN0IGZ1bmN0aW9uIHRoYXQgd2FzIGV4ZWN1dGVkLlxuICAgKiBJZiBpdCBpcyB0aGUgZmlyc3QgZnVuY3Rpb24gaW4gdGhlIGNhbGxiYWNrIGNoYWluIGl0IHdpbGwgYmUgdGhlIGV2ZW50IGRhdGEuXG4gICAqL1xuICBwdWJsaWMgbGFzdFJldHVyblZhbHVlPzogYW55O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgRXZlbnRTdGF0ZVxuICAgKiBAcGFyYW0gbWFzayAtIGRlZmluZXMgdGhlIG1hc2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RhdGVcbiAgICogQHBhcmFtIHNraXBOZXh0T2JzZXJ2ZXJzIC0gZGVmaW5lcyBhIGZsYWcgd2hpY2ggd2lsbCBpbnN0cnVjdCB0aGUgb2JzZXJ2YWJsZSB0byBza2lwIGZvbGxvd2luZyBvYnNlcnZlcnMgd2hlbiBzZXQgdG8gdHJ1ZVxuICAgKiBAcGFyYW0gdGFyZ2V0IC0gZGVmaW5lcyB0aGUgb3JpZ2luYWwgdGFyZ2V0IG9mIHRoZSBzdGF0ZVxuICAgKiBAcGFyYW0gY3VycmVudFRhcmdldCAtIGRlZmluZXMgdGhlIGN1cnJlbnQgdGFyZ2V0IG9mIHRoZSBzdGF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IobWFzazogbnVtYmVyLCBza2lwTmV4dE9ic2VydmVycyA9IGZhbHNlLCB0YXJnZXQ/OiBhbnksIGN1cnJlbnRUYXJnZXQ/OiBhbnkpIHtcbiAgICB0aGlzLmluaXRhbGl6ZShtYXNrLCBza2lwTmV4dE9ic2VydmVycywgdGFyZ2V0LCBjdXJyZW50VGFyZ2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBjdXJyZW50IGV2ZW50IHN0YXRlXG4gICAqIEBwYXJhbSBtYXNrIC0gZGVmaW5lcyB0aGUgbWFzayBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGF0ZVxuICAgKiBAcGFyYW0gc2tpcE5leHRPYnNlcnZlcnMgLSBkZWZpbmVzIGEgZmxhZyB3aGljaCB3aWxsIGluc3RydWN0IHRoZSBvYnNlcnZhYmxlIHRvIHNraXAgZm9sbG93aW5nIG9ic2VydmVycyB3aGVuIHNldCB0byB0cnVlXG4gICAqIEBwYXJhbSB0YXJnZXQgLSBkZWZpbmVzIHRoZSBvcmlnaW5hbCB0YXJnZXQgb2YgdGhlIHN0YXRlXG4gICAqIEBwYXJhbSBjdXJyZW50VGFyZ2V0IC0gZGVmaW5lcyB0aGUgY3VycmVudCB0YXJnZXQgb2YgdGhlIHN0YXRlXG4gICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IGV2ZW50IHN0YXRlXG4gICAqL1xuICBwdWJsaWMgaW5pdGFsaXplKG1hc2s6IG51bWJlciwgc2tpcE5leHRPYnNlcnZlcnMgPSBmYWxzZSwgdGFyZ2V0PzogYW55LCBjdXJyZW50VGFyZ2V0PzogYW55KTogT2JzZXJ2ZXJFdmVudFN0YXRlIHtcbiAgICB0aGlzLm1hc2sgPSBtYXNrO1xuICAgIHRoaXMuc2tpcE5leHRPYnNlcnZlcnMgPSBza2lwTmV4dE9ic2VydmVycztcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGFuIE9ic2VydmVyIHJlZ2lzdGVyZWQgdG8gYSBnaXZlbiBPYnNlcnZhYmxlIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIE9ic2VydmVyPFQ+IHtcbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyBhIHByb3BlcnR5IGRlZmluaW5nIHRoYXQgdGhlIG9ic2VydmVyIGFzIHRvIGJlIHVucmVnaXN0ZXJlZCBhZnRlciB0aGUgbmV4dCBub3RpZmljYXRpb25cbiAgICovXG4gIHB1YmxpYyB1bnJlZ2lzdGVyT25OZXh0Q2FsbCA9IGZhbHNlO1xuXG4gIC8qKiBGb3IgaW50ZXJuYWwgdXNhZ2UgKi9cbiAgcHVibGljIF93aWxsQmVVbnJlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBvYnNlcnZlclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBkZWZpbmVzIHRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIG9ic2VydmVyIGlzIG5vdGlmaWVkXG4gICAqIEBwYXJhbSBtYXNrIC0gZGVmaW5lcyB0aGUgbWFzayBvZiB0aGUgb2JzZXJ2ZXIgKHVzZWQgdG8gZmlsdGVyIG5vdGlmaWNhdGlvbnMpXG4gICAqIEBwYXJhbSBzY29wZSAtIGRlZmluZXMgdGhlIGN1cnJlbnQgc2NvcGUgdXNlZCB0byByZXN0b3JlIHRoZSBKUyBjb250ZXh0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIG9ic2VydmVyIGlzIG5vdGlmaWVkXG4gICAgICovXG4gICAgcHVibGljIGNhbGxiYWNrOiAoZXZlbnREYXRhOiBULCBldmVudFN0YXRlOiBPYnNlcnZlckV2ZW50U3RhdGUpID0+IHZvaWQsXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgbWFzayBvZiB0aGUgb2JzZXJ2ZXIgKHVzZWQgdG8gZmlsdGVyIG5vdGlmaWNhdGlvbnMpXG4gICAgICovXG4gICAgcHVibGljIG1hc2s6IG51bWJlcixcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBjdXJyZW50IHNjb3BlIHVzZWQgdG8gcmVzdG9yZSB0aGUgSlMgY29udGV4dFxuICAgICAqL1xuICAgIHB1YmxpYyBzY29wZTogYW55ID0gbnVsbFxuICApIHt9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgbGlzdCBvZiBvYnNlcnZlcnMgcmVnaXN0ZXJlZCB0byBtdWx0aXBsZSBPYnNlcnZhYmxlcyBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aU9ic2VydmVyPFQ+IHtcbiAgcHJpdmF0ZSBfb2JzZXJ2ZXJzOiBPYnNlcnZlcjxUPltdIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX29ic2VydmFibGVzOiBPYnNlcnZhYmxlPFQ+W10gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogUmFpc2UgYSBjYWxsYmFjayB3aGVuIG9uZSBvZiB0aGUgb2JzZXJ2YWJsZSB3aWxsIG5vdGlmeVxuICAgKiBAcGFyYW0gb2JzZXJ2YWJsZXMgLSBkZWZpbmVzIGEgbGlzdCBvZiBvYnNlcnZhYmxlcyB0byB3YXRjaFxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBkZWZpbmVzIHRoZSBjYWxsYmFjayB0byBjYWxsIG9uIG5vdGlmaWNhdGlvblxuICAgKiBAcGFyYW0gbWFzayAtIGRlZmluZXMgdGhlIG1hc2sgdXNlZCB0byBmaWx0ZXIgbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gc2NvcGUgLSBkZWZpbmVzIHRoZSBjdXJyZW50IHNjb3BlIHVzZWQgdG8gcmVzdG9yZSB0aGUgSlMgY29udGV4dFxuICAgKiBAcmV0dXJucyB0aGUgbmV3IE11bHRpT2JzZXJ2ZXJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgV2F0Y2g8VD4oXG4gICAgb2JzZXJ2YWJsZXM6IE9ic2VydmFibGU8VD5bXSxcbiAgICBjYWxsYmFjazogKGV2ZW50RGF0YTogVCwgZXZlbnRTdGF0ZTogT2JzZXJ2ZXJFdmVudFN0YXRlKSA9PiB2b2lkLFxuICAgIG1hc2s6IG51bWJlciA9IC0xLFxuICAgIHNjb3BlOiBhbnkgPSBudWxsXG4gICk6IE11bHRpT2JzZXJ2ZXI8VD4ge1xuICAgIGxldCByZXN1bHQgPSBuZXcgTXVsdGlPYnNlcnZlcjxUPigpO1xuXG4gICAgcmVzdWx0Ll9vYnNlcnZlcnMgPSBuZXcgQXJyYXk8T2JzZXJ2ZXI8VD4+KCk7XG4gICAgcmVzdWx0Ll9vYnNlcnZhYmxlcyA9IG9ic2VydmFibGVzO1xuXG4gICAgZm9yIChsZXQgb2JzZXJ2YWJsZSBvZiBvYnNlcnZhYmxlcykge1xuICAgICAgbGV0IG9ic2VydmVyID0gb2JzZXJ2YWJsZS5hZGQoY2FsbGJhY2ssIG1hc2ssIGZhbHNlLCBzY29wZSk7XG4gICAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmVzdWx0Ll9vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIGFzc29jaWF0ZWQgcmVzb3VyY2VzXG4gICAqL1xuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fb2JzZXJ2ZXJzICYmIHRoaXMuX29ic2VydmFibGVzKSB7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fb2JzZXJ2ZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlc1tpbmRleF0ucmVtb3ZlKHRoaXMuX29ic2VydmVyc1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX29ic2VydmVycyA9IG51bGw7XG4gICAgdGhpcy5fb2JzZXJ2YWJsZXMgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogVGhlIE9ic2VydmFibGUgY2xhc3MgaXMgYSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIE9ic2VydmFibGUgcGF0dGVybi5cbiAqXG4gKiBUaGVyZSdzIG9uZSBzbGlnaHQgcGFydGljdWxhcml0eSB0aG91Z2g6IGEgZ2l2ZW4gT2JzZXJ2YWJsZSBjYW4gbm90aWZ5IGl0cyBvYnNlcnZlciB1c2luZyBhIHBhcnRpY3VsYXIgbWFzayB2YWx1ZSwgb25seSB0aGUgT2JzZXJ2ZXJzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIG1hc2sgdmFsdWUgd2lsbCBiZSBub3RpZmllZC5cbiAqIFRoaXMgZW5hYmxlIGEgbW9yZSBmaW5lIGdyYWluZWQgZXhlY3V0aW9uIHdpdGhvdXQgaGF2aW5nIHRvIHJlbHkgb24gbXVsdGlwbGUgZGlmZmVyZW50IE9ic2VydmFibGUgb2JqZWN0cy5cbiAqIEZvciBpbnN0YW5jZSB5b3UgbWF5IGhhdmUgYSBnaXZlbiBPYnNlcnZhYmxlIHRoYXQgaGF2ZSBmb3VyIGRpZmZlcmVudCB0eXBlcyBvZiBub3RpZmljYXRpb25zOiBNb3ZlIChtYXNrID0gMHgwMSksIFN0b3AgKG1hc2sgPSAweDAyKSwgVHVybiBSaWdodCAobWFzayA9IDBYMDQpLCBUdXJuIExlZnQgKG1hc2sgPSAwWDA4KS5cbiAqIEEgZ2l2ZW4gb2JzZXJ2ZXIgY2FuIHJlZ2lzdGVyIGl0c2VsZiB3aXRoIG9ubHkgTW92ZSBhbmQgU3RvcCAobWFzayA9IDB4MDMpLCB0aGVuIGl0IHdpbGwgb25seSBiZSBub3RpZmllZCB3aGVuIG9uZSBvZiB0aGVzZSB0d28gb2NjdXJzIGFuZCB3aWxsIG5ldmVyIGJlIGZvciBUdXJuIExlZnQvUmlnaHQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZTxUPiB7XG4gIHByaXZhdGUgX29ic2VydmVycyA9IG5ldyBBcnJheTxPYnNlcnZlcjxUPj4oKTtcblxuICBwcml2YXRlIF9ldmVudFN0YXRlOiBPYnNlcnZlckV2ZW50U3RhdGU7XG5cbiAgcHJpdmF0ZSBfb25PYnNlcnZlckFkZGVkOiBudWxsIHwgKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHZvaWQpID0gbnVsbDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBvYnNlcnZhYmxlXG4gICAqIEBwYXJhbSBvbk9ic2VydmVyQWRkZWQgLSBkZWZpbmVzIGEgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIGEgbmV3IG9ic2VydmVyIGlzIGFkZGVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihvbk9ic2VydmVyQWRkZWQ/OiAob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB2b2lkKSB7XG4gICAgdGhpcy5fZXZlbnRTdGF0ZSA9IG5ldyBPYnNlcnZlckV2ZW50U3RhdGUoMCk7XG5cbiAgICBpZiAob25PYnNlcnZlckFkZGVkKSB7XG4gICAgICB0aGlzLl9vbk9ic2VydmVyQWRkZWQgPSBvbk9ic2VydmVyQWRkZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBPYnNlcnZlciB3aXRoIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2tcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gdGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgdGhhdCBPYnNlcnZlclxuICAgKiBAcGFyYW0gbWFzayAtIHRoZSBtYXNrIHVzZWQgdG8gZmlsdGVyIG9ic2VydmVyc1xuICAgKiBAcGFyYW0gaW5zZXJ0Rmlyc3QgLSBpZiB0cnVlIHRoZSBjYWxsYmFjayB3aWxsIGJlIGluc2VydGVkIGF0IHRoZSBmaXJzdCBwb3NpdGlvbiwgaGVuY2UgZXhlY3V0ZWQgYmVmb3JlIHRoZSBvdGhlcnMgb25lcy4gSWYgZmFsc2UgKGRlZmF1bHQgYmVoYXZpb3IpIHRoZSBjYWxsYmFjayB3aWxsIGJlIGluc2VydGVkIGF0IHRoZSBsYXN0IHBvc2l0aW9uLCBleGVjdXRlZCBhZnRlciBhbGwgdGhlIG90aGVycyBhbHJlYWR5IHByZXNlbnQuXG4gICAqIEBwYXJhbSBzY29wZSAtIG9wdGlvbmFsIHNjb3BlIGZvciB0aGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZyb21cbiAgICogQHBhcmFtIHVucmVnaXN0ZXJPbkZpcnN0Q2FsbCAtIGRlZmluZXMgaWYgdGhlIG9ic2VydmVyIGFzIHRvIGJlIHVucmVnaXN0ZXJlZCBhZnRlciB0aGUgbmV4dCBub3RpZmljYXRpb25cbiAgICogQHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBjcmVhdGVkIGZvciB0aGUgY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyBhZGQoXG4gICAgY2FsbGJhY2s6IChldmVudERhdGE6IFQsIGV2ZW50U3RhdGU6IE9ic2VydmVyRXZlbnRTdGF0ZSkgPT4gdm9pZCxcbiAgICBtYXNrOiBudW1iZXIgPSAtMSxcbiAgICBpbnNlcnRGaXJzdCA9IGZhbHNlLFxuICAgIHNjb3BlOiBhbnkgPSBudWxsLFxuICAgIHVucmVnaXN0ZXJPbkZpcnN0Q2FsbCA9IGZhbHNlXG4gICk6IG51bGwgfCBPYnNlcnZlcjxUPiB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IG9ic2VydmVyID0gbmV3IE9ic2VydmVyKGNhbGxiYWNrLCBtYXNrLCBzY29wZSk7XG4gICAgb2JzZXJ2ZXIudW5yZWdpc3Rlck9uTmV4dENhbGwgPSB1bnJlZ2lzdGVyT25GaXJzdENhbGw7XG5cbiAgICBpZiAoaW5zZXJ0Rmlyc3QpIHtcbiAgICAgIHRoaXMuX29ic2VydmVycy51bnNoaWZ0KG9ic2VydmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vbk9ic2VydmVyQWRkZWQpIHtcbiAgICAgIHRoaXMuX29uT2JzZXJ2ZXJBZGRlZChvYnNlcnZlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9ic2VydmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBPYnNlcnZlciB3aXRoIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgYW5kIHVucmVnaXN0ZXJzIGFmdGVyIHRoZSBuZXh0IG5vdGlmaWNhdGlvblxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSB0aGUgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciB0aGF0IE9ic2VydmVyXG4gICAqIEByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgY3JlYXRlZCBmb3IgdGhlIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgYWRkT25jZShjYWxsYmFjazogKGV2ZW50RGF0YTogVCwgZXZlbnRTdGF0ZTogT2JzZXJ2ZXJFdmVudFN0YXRlKSA9PiB2b2lkKTogbnVsbCB8IE9ic2VydmVyPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5hZGQoY2FsbGJhY2ssIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBPYnNlcnZlciBmcm9tIHRoZSBPYnNlcnZhYmxlIG9iamVjdFxuICAgKiBAcGFyYW0gb2JzZXJ2ZXIgLSB0aGUgaW5zdGFuY2Ugb2YgdGhlIE9ic2VydmVyIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJucyBmYWxzZSBpZiBpdCBkb2Vzbid0IGJlbG9uZyB0byB0aGlzIE9ic2VydmFibGVcbiAgICovXG4gIHB1YmxpYyByZW1vdmUob2JzZXJ2ZXI6IG51bGwgfCBPYnNlcnZlcjxUPik6IGJvb2xlYW4ge1xuICAgIGlmICghb2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgaW5kZXggPSB0aGlzLl9vYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9kZWZlclVucmVnaXN0ZXIob2JzZXJ2ZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIE9ic2VydmFibGUgb2JqZWN0XG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIHRoZSBjYWxsYmFjayB0byByZW1vdmVcbiAgICogQHBhcmFtIHNjb3BlIC0gb3B0aW9uYWwgc2NvcGUuIElmIHVzZWQgb25seSB0aGUgY2FsbGJhY2tzIHdpdGggdGhpcyBzY29wZSB3aWxsIGJlIHJlbW92ZWRcbiAgICogQHJldHVybnMgZmFsc2UgaWYgaXQgZG9lc24ndCBiZWxvbmcgdG8gdGhpcyBPYnNlcnZhYmxlXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlQ2FsbGJhY2soY2FsbGJhY2s6IChldmVudERhdGE6IFQsIGV2ZW50U3RhdGU6IE9ic2VydmVyRXZlbnRTdGF0ZSkgPT4gdm9pZCwgc2NvcGU/OiBhbnkpOiBib29sZWFuIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fb2JzZXJ2ZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKHRoaXMuX29ic2VydmVyc1tpbmRleF0uY2FsbGJhY2sgPT09IGNhbGxiYWNrICYmICghc2NvcGUgfHwgc2NvcGUgPT09IHRoaXMuX29ic2VydmVyc1tpbmRleF0uc2NvcGUpKSB7XG4gICAgICAgIHRoaXMuX2RlZmVyVW5yZWdpc3Rlcih0aGlzLl9vYnNlcnZlcnNbaW5kZXhdKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmeSBhbGwgT2JzZXJ2ZXJzIGJ5IGNhbGxpbmcgdGhlaXIgcmVzcGVjdGl2ZSBjYWxsYmFjayB3aXRoIHRoZSBnaXZlbiBkYXRhXG4gICAqIFdpbGwgcmV0dXJuIHRydWUgaWYgYWxsIG9ic2VydmVycyB3ZXJlIGV4ZWN1dGVkLCBmYWxzZSBpZiBhbiBvYnNlcnZlciBzZXQgc2tpcE5leHRPYnNlcnZlcnMgdG8gdHJ1ZSwgdGhlbiBwcmV2ZW50IHRoZSBzdWJzZXF1ZW50IG9uZXMgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gZXZlbnREYXRhIC0gZGVmaW5lcyB0aGUgZGF0YSB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnNcbiAgICogQHBhcmFtIG1hc2sgLSBkZWZpbmVzIHRoZSBtYXNrIG9mIHRoZSBjdXJyZW50IG5vdGlmaWNhdGlvbiAob2JzZXJ2ZXJzIHdpdGggaW5jb21wYXRpYmxlIG1hc2sgKGllIG1hc2sgJiBvYnNlcnZlci5tYXNrID09PSAwKSB3aWxsIG5vdCBiZSBub3RpZmllZClcbiAgICogQHBhcmFtIHRhcmdldCAtIGRlZmluZXMgdGhlIG9yaWdpbmFsIHRhcmdldCBvZiB0aGUgc3RhdGVcbiAgICogQHBhcmFtIGN1cnJlbnRUYXJnZXQgLSBkZWZpbmVzIHRoZSBjdXJyZW50IHRhcmdldCBvZiB0aGUgc3RhdGVcbiAgICogQHJldHVybnMgZmFsc2UgaWYgdGhlIGNvbXBsZXRlIG9ic2VydmVyIGNoYWluIHdhcyBub3QgcHJvY2Vzc2VkIChiZWNhdXNlIG9uZSBvYnNlcnZlciBzZXQgdGhlIHNraXBOZXh0T2JzZXJ2ZXJzIHRvIHRydWUpXG4gICAqL1xuICBwdWJsaWMgbm90aWZ5T2JzZXJ2ZXJzKGV2ZW50RGF0YTogVCwgbWFzazogbnVtYmVyID0gLTEsIHRhcmdldD86IGFueSwgY3VycmVudFRhcmdldD86IGFueSk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5fb2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZXZlbnRTdGF0ZTtcbiAgICBzdGF0ZS5tYXNrID0gbWFzaztcbiAgICBzdGF0ZS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgc3RhdGUuY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgc3RhdGUuc2tpcE5leHRPYnNlcnZlcnMgPSBmYWxzZTtcbiAgICBzdGF0ZS5sYXN0UmV0dXJuVmFsdWUgPSBldmVudERhdGE7XG5cbiAgICBmb3IgKGxldCBvYnMgb2YgdGhpcy5fb2JzZXJ2ZXJzKSB7XG4gICAgICBpZiAob2JzLl93aWxsQmVVbnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYnMubWFzayAmIG1hc2spIHtcbiAgICAgICAgaWYgKG9icy5zY29wZSkge1xuICAgICAgICAgIHN0YXRlLmxhc3RSZXR1cm5WYWx1ZSA9IG9icy5jYWxsYmFjay5hcHBseShvYnMuc2NvcGUsIFtldmVudERhdGEsIHN0YXRlXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUubGFzdFJldHVyblZhbHVlID0gb2JzLmNhbGxiYWNrKGV2ZW50RGF0YSwgc3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9icy51bnJlZ2lzdGVyT25OZXh0Q2FsbCkge1xuICAgICAgICAgIHRoaXMuX2RlZmVyVW5yZWdpc3RlcihvYnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc2tpcE5leHRPYnNlcnZlcnMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsaW5nIHRoaXMgd2lsbCBleGVjdXRlIGVhY2ggY2FsbGJhY2ssIGV4cGVjdGluZyBpdCB0byBiZSBhIHByb21pc2Ugb3IgcmV0dXJuIGEgdmFsdWUuXG4gICAqIElmIGF0IGFueSBwb2ludCBpbiB0aGUgY2hhaW4gb25lIGZ1bmN0aW9uIGZhaWxzLCB0aGUgcHJvbWlzZSB3aWxsIGZhaWwgYW5kIHRoZSBleGVjdXRpb24gd2lsbCBub3QgY29udGludWUuXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjaGFpbiBvZiBldmVudHMgKHNvbWV0aW1lcyBhc3luYyBldmVudHMpIGlzIG5lZWRlZCB0byBpbml0aWFsaXplIGEgY2VydGFpbiBvYmplY3RcbiAgICogYW5kIGl0IGlzIGNydWNpYWwgdGhhdCBhbGwgY2FsbGJhY2tzIHdpbGwgYmUgZXhlY3V0ZWQuXG4gICAqIFRoZSBvcmRlciBvZiB0aGUgY2FsbGJhY2tzIGlzIGtlcHQsIGNhbGxiYWNrcyBhcmUgbm90IGV4ZWN1dGVkIHBhcmFsbGVsLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnREYXRhIC0gVGhlIGRhdGEgdG8gYmUgc2VudCB0byBlYWNoIGNhbGxiYWNrXG4gICAqIEBwYXJhbSBtYXNrIC0gaXMgdXNlZCB0byBmaWx0ZXIgb2JzZXJ2ZXJzIGRlZmF1bHRzIHRvIC0xXG4gICAqIEBwYXJhbSB0YXJnZXQgLSBkZWZpbmVzIHRoZSBjYWxsYmFjayB0YXJnZXQgKHNlZSBFdmVudFN0YXRlKVxuICAgKiBAcGFyYW0gY3VycmVudFRhcmdldCAtIGRlZmluZXMgaGUgY3VycmVudCBvYmplY3QgaW4gdGhlIGJ1YmJsaW5nIHBoYXNlXG4gICAqIEByZXR1cm5zIHdpbGwgcmV0dXJuIGEgUHJvbWlzZSB0aGFuIHJlc29sdmVzIHdoZW4gYWxsIGNhbGxiYWNrcyBleGVjdXRlZCBzdWNjZXNzZnVsbHkuXG4gICAqL1xuICBwdWJsaWMgbm90aWZ5T2JzZXJ2ZXJzV2l0aFByb21pc2UoZXZlbnREYXRhOiBULCBtYXNrOiBudW1iZXIgPSAtMSwgdGFyZ2V0PzogYW55LCBjdXJyZW50VGFyZ2V0PzogYW55KTogUHJvbWlzZTxUPiB7XG4gICAgLy8gY3JlYXRlIGFuIGVtcHR5IHByb21pc2VcbiAgICBsZXQgcDogUHJvbWlzZTxhbnk+ID0gUHJvbWlzZS5yZXNvbHZlKGV2ZW50RGF0YSk7XG5cbiAgICAvLyBubyBvYnNlcnZlcnM/IHJldHVybiB0aGlzIHByb21pc2UuXG4gICAgaWYgKCF0aGlzLl9vYnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9ldmVudFN0YXRlO1xuICAgIHN0YXRlLm1hc2sgPSBtYXNrO1xuICAgIHN0YXRlLnRhcmdldCA9IHRhcmdldDtcbiAgICBzdGF0ZS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICBzdGF0ZS5za2lwTmV4dE9ic2VydmVycyA9IGZhbHNlO1xuXG4gICAgLy8gZXhlY3V0ZSBvbmUgY2FsbGJhY2sgYWZ0ZXIgYW5vdGhlciAobm90IHVzaW5nIFByb21pc2UuYWxsLCB0aGUgb3JkZXIgaXMgaW1wb3J0YW50KVxuICAgIHRoaXMuX29ic2VydmVycy5mb3JFYWNoKG9icyA9PiB7XG4gICAgICBpZiAoc3RhdGUuc2tpcE5leHRPYnNlcnZlcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9icy5fd2lsbEJlVW5yZWdpc3RlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvYnMubWFzayAmIG1hc2spIHtcbiAgICAgICAgaWYgKG9icy5zY29wZSkge1xuICAgICAgICAgIHAgPSBwLnRoZW4obGFzdFJldHVybmVkVmFsdWUgPT4ge1xuICAgICAgICAgICAgc3RhdGUubGFzdFJldHVyblZhbHVlID0gbGFzdFJldHVybmVkVmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JzLmNhbGxiYWNrLmFwcGx5KG9icy5zY29wZSwgW2V2ZW50RGF0YSwgc3RhdGVdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwID0gcC50aGVuKGxhc3RSZXR1cm5lZFZhbHVlID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmxhc3RSZXR1cm5WYWx1ZSA9IGxhc3RSZXR1cm5lZFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG9icy5jYWxsYmFjayhldmVudERhdGEsIHN0YXRlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JzLnVucmVnaXN0ZXJPbk5leHRDYWxsKSB7XG4gICAgICAgICAgdGhpcy5fZGVmZXJVbnJlZ2lzdGVyKG9icyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHJldHVybiB0aGUgZXZlbnREYXRhXG4gICAgcmV0dXJuIHAudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnREYXRhO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmeSBhIHNwZWNpZmljIG9ic2VydmVyXG4gICAqIEBwYXJhbSBvYnNlcnZlciAtIGRlZmluZXMgdGhlIG9ic2VydmVyIHRvIG5vdGlmeVxuICAgKiBAcGFyYW0gZXZlbnREYXRhIC0gZGVmaW5lcyB0aGUgZGF0YSB0byBiZSBzZW50IHRvIGVhY2ggY2FsbGJhY2tcbiAgICogQHBhcmFtIG1hc2sgLSBpcyB1c2VkIHRvIGZpbHRlciBvYnNlcnZlcnMgZGVmYXVsdHMgdG8gLTFcbiAgICovXG4gIHB1YmxpYyBub3RpZnlPYnNlcnZlcihvYnNlcnZlcjogT2JzZXJ2ZXI8VD4sIGV2ZW50RGF0YTogVCwgbWFzazogbnVtYmVyID0gLTEpOiB2b2lkIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9ldmVudFN0YXRlO1xuICAgIHN0YXRlLm1hc2sgPSBtYXNrO1xuICAgIHN0YXRlLnNraXBOZXh0T2JzZXJ2ZXJzID0gZmFsc2U7XG5cbiAgICBvYnNlcnZlci5jYWxsYmFjayhldmVudERhdGEsIHN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBvYnNlcnZhYmxlIGhhcyBhdCBsZWFzdCBvbmUgb2JzZXJ2ZXJcbiAgICogQHJldHVybnMgdHJ1ZSBpcyB0aGUgT2JzZXJ2YWJsZSBoYXMgYXQgbGVhc3Qgb25lIE9ic2VydmVyIHJlZ2lzdGVyZWRcbiAgICovXG4gIHB1YmxpYyBoYXNPYnNlcnZlcnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX29ic2VydmVycy5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBsaXN0IG9mIG9ic2VydmVyc1xuICAgKi9cbiAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMuX29ic2VydmVycyA9IG5ldyBBcnJheTxPYnNlcnZlcjxUPj4oKTtcbiAgICB0aGlzLl9vbk9ic2VydmVyQWRkZWQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lIHRoZSBjdXJyZW50IG9ic2VydmFibGVcbiAgICogQHJldHVybnMgYSBuZXcgb2JzZXJ2YWJsZVxuICAgKi9cbiAgcHVibGljIGNsb25lKCk6IE9ic2VydmFibGU8VD4ge1xuICAgIGxldCByZXN1bHQgPSBuZXcgT2JzZXJ2YWJsZTxUPigpO1xuXG4gICAgcmVzdWx0Ll9vYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnMuc2xpY2UoMCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIERvZXMgdGhpcyBvYnNlcnZhYmxlIGhhbmRsZXMgb2JzZXJ2ZXIgcmVnaXN0ZXJlZCB3aXRoIGEgZ2l2ZW4gbWFza1xuICAgKiBAcGFyYW0gbWFzayAtIGRlZmluZXMgdGhlIG1hc2sgdG8gYmUgdGVzdGVkXG4gICAqIEByZXR1cm5zIHdoZXRoZXIgb3Igbm90IG9uZSBvYnNlcnZlciByZWdpc3RlcmVkIHdpdGggdGhlIGdpdmVuIG1hc2sgaXMgaGFuZGVsZWRcbiAgICovXG4gIHB1YmxpYyBoYXNTcGVjaWZpY01hc2sobWFzazogbnVtYmVyID0gLTEpOiBib29sZWFuIHtcbiAgICBmb3IgKGxldCBvYnMgb2YgdGhpcy5fb2JzZXJ2ZXJzKSB7XG4gICAgICBpZiAob2JzLm1hc2sgJiBtYXNrIHx8IG9icy5tYXNrID09PSBtYXNrKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIF9kZWZlclVucmVnaXN0ZXIob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KTogdm9pZCB7XG4gICAgb2JzZXJ2ZXIudW5yZWdpc3Rlck9uTmV4dENhbGwgPSBmYWxzZTtcbiAgICBvYnNlcnZlci5fd2lsbEJlVW5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHRoaXMuX3JlbW92ZShvYnNlcnZlcikpO1xuICB9XG5cbiAgLy8gVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlbiBub3QgaXRlcmF0aW5nIG92ZXIgX29ic2VydmVycyB0byBhdm9pZCBjYWxsYmFjayBza2lwcGluZy5cbiAgLy8gUmVtb3ZlcyBhbiBvYnNlcnZlciBmcm9tIHRoZSBfb2JzZXJ2ZXIgQXJyYXkuXG4gIHByaXZhdGUgX3JlbW92ZShvYnNlcnZlcjogbnVsbCB8IE9ic2VydmVyPFQ+KTogYm9vbGVhbiB7XG4gICAgaWYgKCFvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBpbmRleCA9IHRoaXMuX29ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX29ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXX0=