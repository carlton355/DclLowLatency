/// <reference types="node" />
import { Entity, EntityType } from '@dcl/schemas';
import { AuditInfo, AvailableContentResult, Fetcher, HealthStatus, RequestOptions, ServerStatus } from 'dcl-catalyst-commons';
import { Writable } from 'stream';
import { CatalystAPI } from './CatalystAPI';
import { BuildEntityOptions, BuildEntityWithoutFilesOptions } from './ContentClient';
import { EmotesFilters, OwnedItems, ProfileOptions, ServerMetadata, WearablesFilters } from './LambdasAPI';
import { DeploymentBuilder, DeploymentData, DeploymentPreparationData } from './utils/DeploymentBuilder';
export declare type CatalystClientOptions = {
    catalystUrl: string;
    fetcher?: Fetcher;
    deploymentBuilderClass?: typeof DeploymentBuilder;
};
export declare class CatalystClient implements CatalystAPI {
    private readonly contentClient;
    private readonly lambdasClient;
    private readonly catalystUrl;
    constructor(options: CatalystClientOptions);
    buildEntity(options: BuildEntityOptions): Promise<DeploymentPreparationData>;
    buildEntityWithoutNewFiles(options: BuildEntityWithoutFilesOptions): Promise<DeploymentPreparationData>;
    /** @deprecated use deploy instead */
    deployEntity(deployData: DeploymentData, fix?: boolean, options?: RequestOptions): Promise<number>;
    deploy(deployData: DeploymentData, options?: RequestOptions): Promise<unknown>;
    fetchEntitiesByPointers(type: EntityType, pointers: string[], options?: RequestOptions): Promise<Entity[]>;
    fetchEntitiesByIds(type: EntityType, ids: string[], options?: RequestOptions): Promise<Entity[]>;
    fetchEntityById(type: EntityType, id: string, options?: RequestOptions): Promise<Entity>;
    fetchAuditInfo(type: EntityType, id: string, options?: RequestOptions): Promise<AuditInfo>;
    fetchContentStatus(options?: RequestOptions): Promise<ServerStatus>;
    isContentAvailable(cids: string[], options?: RequestOptions): Promise<AvailableContentResult>;
    downloadContent(contentHash: string, options?: RequestOptions): Promise<Buffer>;
    pipeContent(contentHash: string, writeTo: Writable, options?: RequestOptions): Promise<Map<string, string>>;
    fetchProfiles(ethAddresses: string[], profileOptions?: ProfileOptions, options?: RequestOptions): Promise<any[]>;
    fetchWearables(filters: WearablesFilters, options?: RequestOptions): Promise<any[]>;
    fetchOwnedWearables<B extends boolean>(ethAddress: string, includeDefinitions: B, options?: RequestOptions): Promise<OwnedItems<B>>;
    fetchOwnedThirdPartyWearables<B extends boolean>(ethAddress: string, thirdPartyId: string, includeDefinitions: B, options?: RequestOptions): Promise<OwnedItems<B>>;
    fetchEmotes(filters: EmotesFilters, options?: RequestOptions): Promise<any[]>;
    fetchOwnedEmotes<B extends boolean>(ethAddress: string, includeDefinitions: B, options?: RequestOptions): Promise<OwnedItems<B>>;
    fetchOwnedThirdPartyEmotes<B extends boolean>(ethAddress: string, thirdPartyId: string, includeDefinitions: B, options?: RequestOptions): Promise<OwnedItems<B>>;
    fetchCatalystsApprovedByDAO(options?: RequestOptions): Promise<ServerMetadata[]>;
    fetchLambdasStatus(options?: RequestOptions): Promise<{
        contentServerUrl: string;
    }>;
    fetchPeerHealth(options?: RequestOptions): Promise<Record<string, HealthStatus>>;
    getCatalystUrl(): string;
    getContentUrl(): string;
    getLambdasUrl(): string;
    static connectedToCatalystIn(options: CatalystConnectOptions): Promise<CatalystClient>;
}
export declare type CatalystConnectOptions = {
    network: 'mainnet' | 'goerli';
};
