"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FriendsManagementClient = exports.FRIENDSHIP_EVENT_TYPE = void 0;
const types_1 = require("./types");
const Utils_1 = require("./Utils");
const matrix_js_sdk_1 = require("matrix-js-sdk");
var FriendshipStatus;
(function (FriendshipStatus) {
    FriendshipStatus["NOT_FRIENDS"] = "not friends";
    FriendshipStatus["REQUEST_SENT_BY_ME_PENDING"] = "request sent my me pending";
    FriendshipStatus["REQUEST_SENT_TO_ME_PENDING"] = "request sent to me pending";
    FriendshipStatus["FRIENDS"] = "friends";
})(FriendshipStatus || (FriendshipStatus = {}));
exports.FRIENDSHIP_EVENT_TYPE = 'org.decentraland.friendship';
class FriendsManagementClient {
    constructor(matrixClient, socialClient) {
        this.matrixClient = matrixClient;
        this.socialClient = socialClient;
        // Listen to when the sync is finishes, and join all rooms I was invited to
        const resolveOnSync = async (state) => {
            if (state === 'SYNCING') {
                const friends = this.getAllFriends();
                await this.fixAccountData(friends);
                // remove this listener, otherwhise, it'll be listening all the session and calling an invalid function
                matrixClient.removeListener(matrix_js_sdk_1.ClientEvent.Sync, resolveOnSync);
            }
        };
        matrixClient.on(matrix_js_sdk_1.ClientEvent.Sync, resolveOnSync);
    }
    /*
     * Ensure all friends are declared as direct messages under the account data
     */
    async fixAccountData(friends) {
        const mDirectEvent = this.matrixClient.getAccountData(matrix_js_sdk_1.EventType.Direct);
        const directRoomMap = mDirectEvent ? mDirectEvent.getContent() : {};
        let shouldUpdate = false;
        for (const friend of friends) {
            const friendRooms = directRoomMap[friend];
            const room = this.getRoomIdByFriendId(friend);
            if (!room)
                continue;
            if (!friendRooms || !friendRooms.includes(room)) {
                directRoomMap[friend] = [room];
                shouldUpdate = true;
            }
        }
        if (shouldUpdate) {
            await this.matrixClient.setAccountData(matrix_js_sdk_1.EventType.Direct, directRoomMap);
        }
    }
    getRoomIdByFriendId(friendId) {
        const rooms = this.matrixClient.getVisibleRooms();
        return rooms.map((room) => room.guessDMUserId()).find((userId) => userId === friendId);
    }
    getAllFriends() {
        const rooms = this.matrixClient.getVisibleRooms();
        return rooms
            .filter(room => (0, Utils_1.getConversationTypeFromRoom)(this.matrixClient, room) === types_1.ConversationType.DIRECT)
            .filter(room => this.getFriendshipStatusInRoom(room) === FriendshipStatus.FRIENDS)
            .map(room => room.guessDMUserId());
    }
    getPendingRequests() {
        const rooms = this.matrixClient.getVisibleRooms();
        return rooms
            .filter(room => (0, Utils_1.getConversationTypeFromRoom)(this.matrixClient, room) === types_1.ConversationType.DIRECT)
            .map(room => [room, this.getFriendshipStatusInRoom(room)])
            .filter(([, status]) => FriendsManagementClient.PENDING_STATUSES.includes(status))
            .map(([room, status]) => {
            const other = room.guessDMUserId();
            if (status === FriendshipStatus.REQUEST_SENT_BY_ME_PENDING) {
                return { from: this.socialClient.getUserId(), to: other, createdAt: room.timeline[0].getTs() };
            }
            else {
                return { to: this.socialClient.getUserId(), from: other, createdAt: room.timeline[0].getTs() };
            }
        });
    }
    isUserMyFriend(userId) {
        const friends = this.getAllFriends();
        return friends.includes(userId);
    }
    async addAsFriend(userId) {
        return this.actByStatus(userId, 
        // Send request
        this.action(FriendshipStatus.NOT_FRIENDS, userId => this.sendFriendshipEvent(FriendshipEvent.REQUEST, userId)), 
        // Approve friendship
        this.action(FriendshipStatus.REQUEST_SENT_TO_ME_PENDING, userId => this.approveFriendshipRequestFrom(userId)));
    }
    deleteFriendshipWith(userId) {
        return this.actByStatus(userId, 
        // Delete friendship
        this.action(FriendshipStatus.FRIENDS, userId => this.sendFriendshipEvent(FriendshipEvent.DELETE, userId)));
    }
    approveFriendshipRequestFrom(userId) {
        return this.actByStatus(userId, 
        // Accept friendship
        this.action(FriendshipStatus.REQUEST_SENT_TO_ME_PENDING, userId => this.sendFriendshipEvent(FriendshipEvent.ACCEPT, userId)));
    }
    rejectFriendshipRequestFrom(userId) {
        return this.actByStatus(userId, 
        // Reject friendship
        this.action(FriendshipStatus.REQUEST_SENT_TO_ME_PENDING, userId => this.sendFriendshipEvent(FriendshipEvent.REJECT, userId)));
    }
    cancelFriendshipRequestTo(userId) {
        return this.actByStatus(userId, 
        // Cancel friendship request
        this.action(FriendshipStatus.REQUEST_SENT_BY_ME_PENDING, userId => this.sendFriendshipEvent(FriendshipEvent.CANCEL, userId)));
    }
    onFriendshipRequest(listener) {
        return this.listenToEvent(FriendshipEvent.REQUEST, listener);
    }
    onFriendshipRequestCancellation(listener) {
        return this.listenToEvent(FriendshipEvent.CANCEL, listener);
    }
    onFriendshipRequestRejection(listener) {
        return this.listenToEvent(FriendshipEvent.REJECT, listener);
    }
    onFriendshipRequestApproval(listener) {
        return this.listenToEvent(FriendshipEvent.ACCEPT, listener);
    }
    onFriendshipDeletion(listener) {
        return this.listenToEvent(FriendshipEvent.DELETE, listener);
    }
    listenToEvent(eventToListenTo, listener) {
        this.matrixClient.on(matrix_js_sdk_1.RoomEvent.Timeline, (event, _, toStartOfTimeline, __, data) => {
            // Ignore anything but real-time updates at the end of the room
            if (toStartOfTimeline || !data || !data.liveEvent)
                return;
            // Just listen to the unfiltered timeline, so we don't raise the same event more than once
            if (data.timeline.getFilter())
                return;
            if (event.getType() === exports.FRIENDSHIP_EVENT_TYPE && event.getStateKey() === '') {
                const { type } = event.getContent();
                if (type === eventToListenTo && event.getSender() !== this.socialClient.getUserId()) {
                    listener(event.getSender());
                }
            }
        });
    }
    async sendFriendshipEvent(event, otherUser) {
        const { id: roomId } = await this.socialClient.createDirectConversation(otherUser);
        const content = { type: event };
        await this.matrixClient.sendStateEvent(roomId, exports.FRIENDSHIP_EVENT_TYPE, content, '');
        await this.matrixClient.sendStateEvent(roomId, exports.FRIENDSHIP_EVENT_TYPE, content, this.socialClient.getUserId());
    }
    /**
     * Perform an action according to the current friendship status between the logged in user, and the given user id.
     * If an action for the current status isn't provided, then nothing will be done
     */
    async actByStatus(userId, ...actions) {
        const actionsAsEntries = actions.map(({ status, action }) => [status, action]);
        const actionMap = new Map(actionsAsEntries);
        const { id: roomId } = await this.socialClient.createDirectConversation(userId);
        const room = this.matrixClient.getRoom(roomId);
        if (!room) {
            return;
        }
        const status = this.getFriendshipStatusInRoom(room);
        const action = actionMap.get(status);
        if (action) {
            return action(userId);
        }
        return Promise.resolve();
    }
    getFriendshipStatusInRoom(room) {
        const event = (0, Utils_1.getLastFriendshipEventInRoom)(room);
        if (event) {
            const sender = event.getSender();
            const { type } = event.getContent();
            switch (type) {
                case FriendshipEvent.REQUEST:
                    if (sender === this.socialClient.getUserId()) {
                        return FriendshipStatus.REQUEST_SENT_BY_ME_PENDING;
                    }
                    else {
                        return FriendshipStatus.REQUEST_SENT_TO_ME_PENDING;
                    }
                case FriendshipEvent.ACCEPT:
                    // If the last friendship event is FriendshipEvent.ACCEPT, then we perform an extra check, to verify
                    // that both participants actually agreed to the friendship. The start of a friendship MUST be mutual.
                    const othersLastFriendshipEvent = sender === room.guessDMUserId()
                        ? event
                        : this.getLastFriendshipEventInRoomByUser(room, room.guessDMUserId());
                    const myLastFriendshipEvent = sender === this.socialClient.getUserId()
                        ? event
                        : this.getLastFriendshipEventInRoomByUser(room, this.socialClient.getUserId());
                    if (othersLastFriendshipEvent && myLastFriendshipEvent) {
                        const wasInvited = othersLastFriendshipEvent.getContent().type === FriendshipEvent.REQUEST &&
                            myLastFriendshipEvent.getContent().type === FriendshipEvent.ACCEPT;
                        const didTheInvite = othersLastFriendshipEvent.getContent().type === FriendshipEvent.ACCEPT &&
                            myLastFriendshipEvent.getContent().type === FriendshipEvent.REQUEST;
                        if (wasInvited || didTheInvite) {
                            return FriendshipStatus.FRIENDS;
                        }
                    }
                    break;
                case FriendshipEvent.CANCEL:
                case FriendshipEvent.REJECT:
                case FriendshipEvent.DELETE:
                    return FriendshipStatus.NOT_FRIENDS;
            }
        }
        return FriendshipStatus.NOT_FRIENDS;
    }
    getLastFriendshipEventInRoomByUser(room, userId) {
        const lastFriendshipEvent = (0, Utils_1.getLastFriendshipEventInRoom)(room, userId);
        // Make sure that the sender was the actual user
        if (lastFriendshipEvent && lastFriendshipEvent.getSender() === userId) {
            return lastFriendshipEvent;
        }
        return undefined;
    }
    action(status, action) {
        return {
            status,
            action
        };
    }
}
exports.FriendsManagementClient = FriendsManagementClient;
FriendsManagementClient.PENDING_STATUSES = [
    FriendshipStatus.REQUEST_SENT_TO_ME_PENDING,
    FriendshipStatus.REQUEST_SENT_BY_ME_PENDING
];
var FriendshipEvent;
(function (FriendshipEvent) {
    FriendshipEvent["REQUEST"] = "request";
    FriendshipEvent["CANCEL"] = "cancel";
    FriendshipEvent["ACCEPT"] = "accept";
    FriendshipEvent["REJECT"] = "reject";
    FriendshipEvent["DELETE"] = "delete"; // Delete an existing friendship
})(FriendshipEvent || (FriendshipEvent = {}));
//# sourceMappingURL=FriendsManagementClient.js.map