import { MatrixClient } from 'matrix-js-sdk/lib/client';
import { Room } from 'matrix-js-sdk/lib/models/room';
import { Conversation, SocialId, TextMessage, MessageId, CursorOptions, ConversationId, BasicMessageInfo, GetOrCreateConversationResponse, SearchChannelsResponse, ProfileInfo, Member } from './types';
import { ConversationCursor } from './ConversationCursor';
import { MessagingAPI } from './MessagingAPI';
import { SocialClient } from 'SocialClient';
export declare class MessagingClient implements MessagingAPI {
    private readonly matrixClient;
    private readonly socialClient;
    private readonly lastSentMessage;
    constructor(matrixClient: MatrixClient, socialClient: SocialClient);
    listenToEvents(): void;
    getRoomInformation(room: Room): {
        conversation: Conversation;
        unreadMessages: boolean;
    };
    getProfileInfo(userId: string): Promise<ProfileInfo>;
    getMemberInfo(roomId: string, userId: string): ProfileInfo;
    /** Get all conversation the user has joined */
    getAllCurrentConversations(): {
        conversation: Conversation;
        unreadMessages: boolean;
    }[];
    /** Get all conversation the user has joined */
    getAllConversationsWithUnreadMessages(): Conversation[];
    /** Get total number of unseen messages from all conversations the user has joined */
    getTotalUnseenMessages(): number;
    /**
     * Send a message text to a conversation.
     * Returns the message id
     */
    sendMessageTo(conversationId: ConversationId, message: string): Promise<MessageId>;
    /** Mark a message (and all those that came before it on the conversation) as read */
    markAsRead(conversationId: ConversationId, messageId: MessageId): Promise<void>;
    /** Mark all messages in the conversation as seen */
    markMessagesAsSeen(conversationId: ConversationId): Promise<void>;
    /**
     * Listen to new messages
     */
    onMessage(listener: (conversation: Conversation, message: TextMessage) => void): void;
    /**
     * Listen to updates on the membership of a channel
     * @doc {membership} join | leave | invite
     */
    onChannelMembership(listener: (conversation: Conversation, membership: string) => void): void;
    /**
     * Listen to updates on the members of a channel
     */
    onChannelMembers(listener: (conversation: Conversation, members: Member[]) => void): void;
    /**
     * Return basic information about the last read message. Since we don't mark messages sent by me as read,
     * we also check against the last sent message.
     */
    getLastReadMessage(conversationId: ConversationId): BasicMessageInfo | undefined;
    /** Returns a cursor located on the given message. If there is no given message, then it is
     * located at the end of the conversation.
     */
    getCursorOnMessage(conversationId: ConversationId, messageId?: MessageId, options?: CursorOptions): Promise<ConversationCursor | undefined>;
    /**
     * Returns a cursor located on the last read message. If no messages were read, then
     * it is located at the end of the conversation.
     */
    getCursorOnLastRead(conversationId: ConversationId, options?: CursorOptions): Promise<ConversationCursor | undefined>;
    /**
     * Returns a cursor located at the end of the conversation
     */
    getCursorOnLastMessage(conversationId: ConversationId, options?: CursorOptions): Promise<ConversationCursor | undefined>;
    /** Get or create a direct conversation with the given user */
    createDirectConversation(userId: SocialId): Promise<Conversation>;
    /** Get or create a group conversation with the given users
     * This is a direct conversation between multiple users
     */
    createGroupConversation(conversationName: string, userIds: SocialId[]): Promise<Conversation>;
    /** Get or create a channel with the given users
     * If the channel already exists this will return the channel and won't invite the passed ids
     * If the channel is created, all user ids will be invited to join
     */
    getOrCreateChannel(channelName: string, userIds: SocialId[]): Promise<GetOrCreateConversationResponse>;
    /** Join a channel */
    joinChannel(roomIdOrChannelAlias: string): Promise<void>;
    leaveChannel(roomId: string): Promise<void>;
    /** Return whether a conversation has unread messages or not */
    doesConversationHaveUnreadMessages(conversationId: ConversationId): boolean;
    /** Return a conversation unread messages */
    getConversationUnreadMessages(conversationId: ConversationId): BasicMessageInfo[];
    /**
     * Get the conversation for a channel that exists locally, if it doesn't returns undefined
     * @param roomId the roomId of the channel
     */
    getChannel(roomId: string): Conversation | undefined;
    /**
     * Get the conversation for a channel by its name.
     * @param alias the name of the channel.
     * @returns `Promise<Conversation>` if it exists | `Promise<undefined>` if it does not exist.
     */
    getChannelByName(alias: string): Promise<Conversation | undefined>;
    searchChannel(limit: number, searchTerm?: string, since?: string): Promise<SearchChannelsResponse>;
    private assertThatUsersExist;
    /**
     * Find or create a conversation for the given other users. There is no need to include the
     * current user id.
     */
    private getOrCreateConversation;
    private findRoomByAliasLocally;
    private joinRoom;
    private buildAliasForConversationWithUsers;
    private toLocalpart;
    private undefinedIfError;
    private getAllRooms;
    private addDirectRoomToUser;
    private getRoomUnreadMessages;
    private doesRoomHaveUnreadMessages;
}
export declare enum ChannelErrorKind {
    GET_OR_CREATE = 0,
    BAD_REGEX = 1,
    RESERVED_NAME = 2,
    JOIN = 3,
    LEAVE = 4,
    SEARCH = 5
}
export declare class ChannelsError extends Error {
    private readonly kind;
    constructor(kind: ChannelErrorKind);
    getKind(): ChannelErrorKind;
}
export declare class UnknownUsersError extends Error {
    private readonly unknownUsers;
    constructor(unknownUsers: SocialId[]);
    getUnknownUsers(): SocialId[];
}
