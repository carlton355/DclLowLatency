"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLastFriendshipEventInRoom = exports.matrixEventToBasicEventInfo = exports.getOnlyMessagesSentByMeTimelineSetFromRoom = exports.getOnlyMessagesTimelineSetFromRoom = exports.waitForNextSync = exports.getConversationTypeFromRoom = exports.buildTextMessage = exports.findEventInRoom = exports.login = void 0;
const filter_1 = require("matrix-js-sdk/lib/filter");
const types_1 = require("./types");
const matrix_js_sdk_1 = require("matrix-js-sdk");
const FriendsManagementClient_1 = require("./FriendsManagementClient");
// just *accessing* indexedDB throws an exception in firefox with
// indexeddb disabled.
let localStorage;
let indexedDB;
try {
    indexedDB = window.indexedDB;
    localStorage = window.localStorage;
}
catch (e) { }
async function login(synapseUrl, ethAddress, timestamp, authChain, getLocalStorage, createOpts) {
    let store;
    let storage;
    if (getLocalStorage) {
        storage = getLocalStorage();
    }
    else {
        storage = localStorage;
    }
    if (indexedDB) {
        let opts = { indexedDB, localStorage: storage, dbName: `${ethAddress}:${synapseUrl}` };
        store = new matrix_js_sdk_1.IndexedDBStore(opts);
        await store.startup(); // load from indexed db
    }
    else {
        store = new matrix_js_sdk_1.MemoryStore({ localStorage: storage });
    }
    // Create the client
    const matrixClient = (0, matrix_js_sdk_1.createClient)(Object.assign(Object.assign({}, createOpts), { baseUrl: synapseUrl, timelineSupport: true, useAuthorizationHeader: true, store }));
    // Actual login
    await matrixClient.login('m.login.decentraland', {
        identifier: {
            type: 'm.id.user',
            user: ethAddress.toLowerCase()
        },
        timestamp: timestamp.toString(),
        auth_chain: authChain
    });
    return matrixClient;
}
exports.login = login;
function findEventInRoom(client, roomId, eventId) {
    const room = client.getRoom(roomId);
    const timelineSet = room === null || room === void 0 ? void 0 : room.getUnfilteredTimelineSet();
    return timelineSet === null || timelineSet === void 0 ? void 0 : timelineSet.findEventById(eventId);
}
exports.findEventInRoom = findEventInRoom;
function buildTextMessage(event, status) {
    return {
        text: event.getContent().body,
        timestamp: event.getTs(),
        sender: event.getSender(),
        status: status,
        id: event.getId()
    };
}
exports.buildTextMessage = buildTextMessage;
function getConversationTypeFromRoom(client, room) {
    if (room.getType() === types_1.CHANNEL_TYPE) {
        return types_1.ConversationType.CHANNEL;
    }
    if (room.getInvitedAndJoinedMemberCount() === 2 && isDirectRoom(client, room)) {
        return types_1.ConversationType.DIRECT;
    }
    return types_1.ConversationType.GROUP;
}
exports.getConversationTypeFromRoom = getConversationTypeFromRoom;
function isDirectRoom(client, room) {
    var _a;
    // Check if there is a friendship event
    const friendshipEvent = getLastFriendshipEventInRoom(room);
    if (friendshipEvent) {
        return true;
    }
    // If there is no friendship event, then check if conversation was added as DM in the account data
    const membersWhoAreNotMe = room.currentState.getMembers().filter(member => member.userId !== client.getUserId());
    const otherMember = membersWhoAreNotMe[0].userId;
    const mDirectEvent = client.getAccountData('m.direct');
    const directRoomMap = mDirectEvent ? mDirectEvent.getContent() : {};
    const directRoomsToClient = (_a = directRoomMap[otherMember]) !== null && _a !== void 0 ? _a : [];
    if (directRoomsToClient.includes(room.roomId)) {
        return true;
    }
    return false;
}
/*
 * Call this function when you want to wait for sync to finish
 * Not meant to be used in other place than Matrix event processing
 */
async function waitForNextSync(client) {
    // Listen to Sync event
    return new Promise(resolve => {
        client.once(matrix_js_sdk_1.ClientEvent.Sync, () => {
            resolve(void 0);
        });
    });
}
exports.waitForNextSync = waitForNextSync;
function getOnlyMessagesTimelineSetFromRoom(userId, room, limit) {
    const filter = GET_ONLY_MESSAGES_FILTER(userId, limit);
    return room === null || room === void 0 ? void 0 : room.getOrCreateFilteredTimelineSet(filter);
}
exports.getOnlyMessagesTimelineSetFromRoom = getOnlyMessagesTimelineSetFromRoom;
function getOnlyMessagesSentByMeTimelineSetFromRoom(client, room) {
    const filter = GET_ONLY_MESSAGES_SENT_BY_ME_FILTER(client.getUserId());
    return room === null || room === void 0 ? void 0 : room.getOrCreateFilteredTimelineSet(filter);
}
exports.getOnlyMessagesSentByMeTimelineSetFromRoom = getOnlyMessagesSentByMeTimelineSetFromRoom;
function matrixEventToBasicEventInfo(event) {
    return { id: event.getId(), timestamp: event.getTs() };
}
exports.matrixEventToBasicEventInfo = matrixEventToBasicEventInfo;
function getLastFriendshipEventInRoom(room, key = '') {
    return room.currentState.getStateEvents(FriendsManagementClient_1.FRIENDSHIP_EVENT_TYPE, key);
}
exports.getLastFriendshipEventInRoom = getLastFriendshipEventInRoom;
/** Build a filter that only keeps messages in a room */
const GET_ONLY_MESSAGES_FILTER = (userId, limit) => filter_1.Filter.fromJson(userId, 'ONLY_MESSAGES_FILTER', {
    room: {
        timeline: {
            limit: limit !== null && limit !== void 0 ? limit : 30,
            types: ['m.room.message']
        }
    }
});
const GET_ONLY_MESSAGES_SENT_BY_ME_FILTER = (userId, limit) => filter_1.Filter.fromJson(userId, 'ONLY_MESSAGES_SENT_BY_ME_FILTER', {
    room: {
        timeline: {
            limit: limit !== null && limit !== void 0 ? limit : 30,
            senders: [userId],
            types: ['m.room.message']
        }
    }
});
//# sourceMappingURL=Utils.js.map