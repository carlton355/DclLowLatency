"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionManagementClient = void 0;
const types_1 = require("./types");
const matrix_js_sdk_1 = require("matrix-js-sdk");
class SessionManagementClient {
    constructor(matrixClient, socialClient) {
        this.matrixClient = matrixClient;
        this.socialClient = socialClient;
        this.loggedIn = true;
    }
    isLoggedIn() {
        return this.loggedIn;
    }
    async logout() {
        this.loggedIn = false;
        this.matrixClient.stopClient();
        await this.matrixClient.logout();
    }
    /*
     * UserId should be present when client is logged-in
     */
    getUserId() {
        const userId = this.matrixClient.getUserId();
        if (!userId) {
            // shouldn't happen since user id must be present when client is logged in
            throw new Error('UserId not present when it should');
        }
        return userId;
    }
    getDomain() {
        return this.matrixClient.getDomain();
    }
    async setProfileInfo({ displayName, avatarUrl }) {
        const userId = this.getUserId();
        const userInfo = await this.matrixClient.getProfileInfo(userId);
        if (displayName && userInfo.displayname !== displayName) {
            await this.matrixClient.setDisplayName(displayName);
        }
        if (avatarUrl && userInfo.avatar_url !== avatarUrl) {
            await this.matrixClient.setAvatarUrl(avatarUrl);
        }
    }
    setStatus(status) {
        const input = {
            presence: status.presence,
            status_msg: JSON.stringify({ realm: status.realm, position: status.position })
        };
        return this.matrixClient.setPresence(input);
    }
    getUserStatuses(...users) {
        const entries = users
            .map(userId => this.matrixClient.getUser(userId))
            .filter((user) => !!user)
            .map(user => [user.userId, SessionManagementClient.userToStatus(user)]);
        return new Map(entries);
    }
    onStatusChange(listener) {
        const socialClient = this.socialClient;
        this.matrixClient.on(matrix_js_sdk_1.UserEvent.Presence, async (event, user) => {
            if (!event)
                return;
            const sender = event.getSender();
            if (sender !== this.getUserId() && socialClient.isUserMyFriend(sender)) {
                listener(sender, SessionManagementClient.eventToStatus(user));
            }
        });
    }
    static eventToStatus(user) {
        const presenceData = {
            presence: user.presence,
            lastActiveAgo: user.lastActiveAgo,
            presenceStatusMsg: user.presenceStatusMsg
        };
        return SessionManagementClient.userToStatus(presenceData);
    }
    static userToStatus(user) {
        const presence = types_1.PresenceType[user.presence.toUpperCase().trim()];
        const userStatus = {
            presence,
            lastActiveAgo: user.lastActiveAgo
        };
        if (presence !== types_1.PresenceType.OFFLINE && user.presenceStatusMsg) {
            try {
                const parseResult = JSON.parse(user.presenceStatusMsg);
                if (parseResult === null || parseResult === void 0 ? void 0 : parseResult.realm) {
                    userStatus.realm = parseResult === null || parseResult === void 0 ? void 0 : parseResult.realm;
                }
                if (parseResult === null || parseResult === void 0 ? void 0 : parseResult.position) {
                    userStatus.position = parseResult === null || parseResult === void 0 ? void 0 : parseResult.position;
                }
            }
            catch (error) { }
        }
        return userStatus;
    }
}
exports.SessionManagementClient = SessionManagementClient;
//# sourceMappingURL=SessionManagementClient.js.map