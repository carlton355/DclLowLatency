"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocialClient = void 0;
const MessagingClient_1 = require("./MessagingClient");
const SessionManagementClient_1 = require("./SessionManagementClient");
const FriendsManagementClient_1 = require("./FriendsManagementClient");
const Utils_1 = require("./Utils");
const matrix_js_sdk_1 = require("matrix-js-sdk");
class SocialClient {
    constructor(matrixClient) {
        this.sessionManagement = new SessionManagementClient_1.SessionManagementClient(matrixClient, this);
        this.friendsManagement = new FriendsManagementClient_1.FriendsManagementClient(matrixClient, this);
        this.messaging = new MessagingClient_1.MessagingClient(matrixClient, this);
    }
    listenToEvents() {
        this.messaging.listenToEvents();
    }
    static async loginToServer(synapseUrl, ethAddress, timestamp, authChain, options) {
        // Destructure options
        const _options = Object.assign({ pendingEventOrdering: matrix_js_sdk_1.PendingEventOrdering.Detached, initialSyncLimit: 3, disablePresence: false }, options);
        // Login
        const matrixClient = await (0, Utils_1.login)(synapseUrl, ethAddress, timestamp, authChain, options === null || options === void 0 ? void 0 : options.getLocalStorage, options === null || options === void 0 ? void 0 : options.createOpts);
        // Listen to initial sync
        const waitForInitialSync = new Promise(resolve => {
            const resolveOnSync = (state) => {
                if (state === 'SYNCING') {
                    resolve(void 0);
                    // remove this listener, otherwhise, it'll be listening all the session and calling an invalid function
                    matrixClient.removeListener(matrix_js_sdk_1.ClientEvent.Sync, resolveOnSync);
                    return;
                }
            };
            matrixClient.on(matrix_js_sdk_1.ClientEvent.Sync, resolveOnSync);
        });
        // Create the client before starting the matrix client, so our event hooks can detect all events during the initial sync
        const socialClient = new SocialClient(matrixClient);
        // Start the client
        await matrixClient.startClient(_options);
        // Wait for sync from cache + incremental sync
        await waitForInitialSync;
        // Starting listening to new events after initial sync
        socialClient.listenToEvents();
        return socialClient;
    }
    //////    SESSION - STATUS MANAGEMENT    //////
    isLoggedIn() {
        return this.sessionManagement.isLoggedIn();
    }
    logout() {
        return this.sessionManagement.logout();
    }
    getUserId() {
        return this.sessionManagement.getUserId();
    }
    getDomain() {
        return this.sessionManagement.getDomain();
    }
    setStatus(status) {
        return this.sessionManagement.setStatus(status);
    }
    getMemberInfo(roomId, userId) {
        return this.messaging.getMemberInfo(roomId, userId);
    }
    getProfileInfo(userId) {
        return this.messaging.getProfileInfo(userId);
    }
    setProfileInfo(profileInfo) {
        return this.sessionManagement.setProfileInfo(profileInfo);
    }
    getUserStatuses(...users) {
        return this.sessionManagement.getUserStatuses(...users);
    }
    onStatusChange(listener) {
        return this.sessionManagement.onStatusChange(listener);
    }
    //////             MESSAGING             //////
    getAllCurrentConversations() {
        return this.messaging.getAllCurrentConversations();
    }
    getAllConversationsWithUnreadMessages() {
        return this.messaging.getAllConversationsWithUnreadMessages();
    }
    getTotalUnseenMessages() {
        return this.messaging.getTotalUnseenMessages();
    }
    sendMessageTo(conversationId, message) {
        return this.messaging.sendMessageTo(conversationId, message);
    }
    markAsRead(conversationId, messageId) {
        return this.messaging.markAsRead(conversationId, messageId);
    }
    markMessagesAsSeen(conversationId) {
        return this.messaging.markMessagesAsSeen(conversationId);
    }
    onMessage(listener) {
        return this.messaging.onMessage(listener);
    }
    onChannelMembership(listener) {
        return this.messaging.onChannelMembership(listener);
    }
    onChannelMembers(listener) {
        return this.messaging.onChannelMembers(listener);
    }
    getLastReadMessage(conversationId) {
        return this.messaging.getLastReadMessage(conversationId);
    }
    getCursorOnMessage(conversationId, messageId, options) {
        return this.messaging.getCursorOnMessage(conversationId, messageId, options);
    }
    getCursorOnLastRead(conversationId, options) {
        return this.messaging.getCursorOnLastRead(conversationId, options);
    }
    getCursorOnLastMessage(conversationId, options) {
        return this.messaging.getCursorOnLastMessage(conversationId, options);
    }
    createDirectConversation(userId) {
        return this.messaging.createDirectConversation(userId);
    }
    doesConversationHaveUnreadMessages(conversationId) {
        return this.messaging.doesConversationHaveUnreadMessages(conversationId);
    }
    getConversationUnreadMessages(conversationId) {
        return this.messaging.getConversationUnreadMessages(conversationId);
    }
    //////        FRIENDS MANAGEMENT         //////
    getAllFriends() {
        return this.friendsManagement.getAllFriends();
    }
    getPendingRequests() {
        return this.friendsManagement.getPendingRequests();
    }
    isUserMyFriend(userId) {
        return this.friendsManagement.isUserMyFriend(userId);
    }
    addAsFriend(userId) {
        return this.friendsManagement.addAsFriend(userId);
    }
    deleteFriendshipWith(userId) {
        return this.friendsManagement.deleteFriendshipWith(userId);
    }
    approveFriendshipRequestFrom(userId) {
        return this.friendsManagement.approveFriendshipRequestFrom(userId);
    }
    rejectFriendshipRequestFrom(userId) {
        return this.friendsManagement.rejectFriendshipRequestFrom(userId);
    }
    cancelFriendshipRequestTo(userId) {
        return this.friendsManagement.cancelFriendshipRequestTo(userId);
    }
    onFriendshipRequest(listener) {
        return this.friendsManagement.onFriendshipRequest(listener);
    }
    onFriendshipRequestCancellation(listener) {
        return this.friendsManagement.onFriendshipRequestCancellation(listener);
    }
    onFriendshipRequestRejection(listener) {
        return this.friendsManagement.onFriendshipRequestRejection(listener);
    }
    onFriendshipRequestApproval(listener) {
        return this.friendsManagement.onFriendshipRequestApproval(listener);
    }
    onFriendshipDeletion(listener) {
        return this.friendsManagement.onFriendshipDeletion(listener);
    }
    getChannel(roomId) {
        return this.messaging.getChannel(roomId);
    }
    getChannelByName(alias) {
        return this.messaging.getChannelByName(alias);
    }
    getOrCreateChannel(channelName, userIds) {
        return this.messaging.getOrCreateChannel(channelName, userIds);
    }
    joinChannel(roomIdOrChannelAlias) {
        return this.messaging.joinChannel(roomIdOrChannelAlias);
    }
    leaveChannel(roomId) {
        return this.messaging.leaveChannel(roomId);
    }
    searchChannel(limit, searchTerm, since) {
        return this.messaging.searchChannel(limit, searchTerm, since);
    }
}
exports.SocialClient = SocialClient;
//# sourceMappingURL=SocialClient.js.map