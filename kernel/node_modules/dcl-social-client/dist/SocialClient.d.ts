import { AuthChain, EthAddress } from '@dcl/crypto';
import { Timestamp, Conversation, SocialId, TextMessage, MessageId, CursorOptions, ConversationId, BasicMessageInfo, FriendshipRequest, CurrentUserStatus, UpdateUserStatus, GetOrCreateConversationResponse, SearchChannelsResponse, ProfileInfo, Member } from './types';
import { ConversationCursor } from './ConversationCursor';
import { SocialAPI } from './SocialAPI';
import { ICreateClientOpts, PendingEventOrdering } from 'matrix-js-sdk';
export declare type ClientLoginOptions = {
    pendingEventOrdering: PendingEventOrdering;
    disablePresence: boolean;
    initialSyncLimit: number;
    getLocalStorage?: () => Storage;
    createOpts?: Partial<ICreateClientOpts>;
};
export declare class SocialClient implements SocialAPI {
    private readonly sessionManagement;
    private readonly messaging;
    private readonly friendsManagement;
    private constructor();
    listenToEvents(): void;
    static loginToServer(synapseUrl: string, ethAddress: EthAddress, timestamp: Timestamp, authChain: AuthChain, options?: Partial<ClientLoginOptions> | undefined): Promise<SocialClient>;
    isLoggedIn(): boolean;
    logout(): Promise<void>;
    getUserId(): SocialId;
    getDomain(): string;
    setStatus(status: UpdateUserStatus): Promise<void>;
    getMemberInfo(roomId: string, userId: string): ProfileInfo;
    getProfileInfo(userId: string): Promise<ProfileInfo>;
    setProfileInfo(profileInfo: ProfileInfo): Promise<void>;
    getUserStatuses(...users: SocialId[]): Map<SocialId, CurrentUserStatus>;
    onStatusChange(listener: (userId: SocialId, status: CurrentUserStatus) => void): void;
    getAllCurrentConversations(): {
        conversation: Conversation;
        unreadMessages: boolean;
    }[];
    getAllConversationsWithUnreadMessages(): Conversation[];
    getTotalUnseenMessages(): number;
    sendMessageTo(conversationId: ConversationId, message: string): Promise<MessageId>;
    markAsRead(conversationId: ConversationId, messageId: MessageId): Promise<void>;
    markMessagesAsSeen(conversationId: ConversationId): Promise<void>;
    onMessage(listener: (conversation: Conversation, message: TextMessage) => void): void;
    onChannelMembership(listener: (conversation: Conversation, membership: string) => void): void;
    onChannelMembers(listener: (conversation: Conversation, members: Member[]) => void): void;
    getLastReadMessage(conversationId: ConversationId): BasicMessageInfo | undefined;
    getCursorOnMessage(conversationId: ConversationId, messageId?: MessageId, options?: CursorOptions): Promise<ConversationCursor | undefined>;
    getCursorOnLastRead(conversationId: ConversationId, options?: CursorOptions): Promise<ConversationCursor | undefined>;
    getCursorOnLastMessage(conversationId: ConversationId, options?: CursorOptions): Promise<ConversationCursor | undefined>;
    createDirectConversation(userId: SocialId): Promise<Conversation>;
    doesConversationHaveUnreadMessages(conversationId: ConversationId): boolean;
    getConversationUnreadMessages(conversationId: ConversationId): Array<BasicMessageInfo>;
    getAllFriends(): SocialId[];
    getPendingRequests(): FriendshipRequest[];
    isUserMyFriend(userId: SocialId): boolean;
    addAsFriend(userId: SocialId): Promise<void>;
    deleteFriendshipWith(userId: SocialId): Promise<void>;
    approveFriendshipRequestFrom(userId: SocialId): Promise<void>;
    rejectFriendshipRequestFrom(userId: SocialId): Promise<void>;
    cancelFriendshipRequestTo(userId: SocialId): Promise<void>;
    onFriendshipRequest(listener: (requestedBy: SocialId) => void): void;
    onFriendshipRequestCancellation(listener: (canceledBy: SocialId) => void): void;
    onFriendshipRequestRejection(listener: (rejectedBy: SocialId) => void): void;
    onFriendshipRequestApproval(listener: (approvedBy: SocialId) => void): void;
    onFriendshipDeletion(listener: (deletedBy: SocialId) => void): void;
    getChannel(roomId: string): Conversation | undefined;
    getChannelByName(alias: string): Promise<Conversation | undefined>;
    getOrCreateChannel(channelName: string, userIds: string[]): Promise<GetOrCreateConversationResponse>;
    joinChannel(roomIdOrChannelAlias: string): Promise<void>;
    leaveChannel(roomId: string): Promise<void>;
    searchChannel(limit: number, searchTerm?: string, since?: string): Promise<SearchChannelsResponse>;
}
