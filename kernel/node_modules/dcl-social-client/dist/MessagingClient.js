"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnknownUsersError = exports.ChannelsError = exports.ChannelErrorKind = exports.MessagingClient = void 0;
const event_1 = require("matrix-js-sdk/lib/models/event");
const room_1 = require("matrix-js-sdk/lib/models/room");
const types_1 = require("./types");
const Utils_1 = require("./Utils");
const ConversationCursor_1 = require("./ConversationCursor");
const matrix_js_sdk_1 = require("matrix-js-sdk");
/**
 * The channel name should always match with the regex: ^[a-zA-Z0-9-]{3,20}$
 * @param channelId a string with the channelId to validate
 * */
function validateRegexChannelId(channelId) {
    const regex = /^[a-zA-Z0-9-]{3,20}$/;
    if (channelId.match(regex))
        return true;
    return false;
}
const CHANNEL_RESERVED_IDS = ['nearby'];
class MessagingClient {
    constructor(matrixClient, socialClient) {
        this.matrixClient = matrixClient;
        this.socialClient = socialClient;
        this.lastSentMessage = new Map();
        // Listen to when the sync is finishes, and join all rooms I was invited to
        const resolveOnSync = async (state) => {
            if (state === 'SYNCING') {
                const rooms = this.getAllRooms();
                const join = rooms
                    .filter(room => room.getMyMembership() === 'invite') // Consider rooms that I have been invited to
                    .map(room => {
                    const member = room.getMember(this.socialClient.getUserId());
                    return this.joinRoom(member);
                });
                await Promise.all(join);
                // remove this listener, otherwhise, it'll be listening all the session and calling an invalid function
                matrixClient.removeListener(matrix_js_sdk_1.ClientEvent.Sync, resolveOnSync);
            }
        };
        matrixClient.on(matrix_js_sdk_1.ClientEvent.Sync, resolveOnSync);
    }
    listenToEvents() {
        // Listen to events, and store the last message I send
        this.matrixClient.on(room_1.RoomEvent.Timeline, (event, room) => {
            if (event.getType() === 'm.room.message' &&
                event.getContent().msgtype === types_1.MessageType.TEXT &&
                event.getSender() === this.socialClient.getUserId()) {
                const currentLastSentMessage = this.lastSentMessage.get(room.roomId);
                if (!currentLastSentMessage || currentLastSentMessage.timestamp < event.getTs()) {
                    this.lastSentMessage.set(room.roomId, (0, Utils_1.matrixEventToBasicEventInfo)(event));
                }
            }
        });
        // Listen to invitations and accept them automatically
        this.matrixClient.on(matrix_js_sdk_1.RoomMemberEvent.Membership, async (_, member) => {
            if (member.membership === 'invite' && member.userId === this.socialClient.getUserId()) {
                await this.joinRoom(member);
            }
        });
    }
    getRoomInformation(room) {
        var _a;
        const otherId = room.guessDMUserId();
        const unreadMessages = this.getRoomUnreadMessages(room);
        const type = (0, Utils_1.getConversationTypeFromRoom)(this.matrixClient, room);
        return {
            unreadMessages: this.doesRoomHaveUnreadMessages(room),
            conversation: {
                id: room.roomId,
                type,
                unreadMessages: unreadMessages.length > 0 ? unreadMessages : undefined,
                lastEventTimestamp: (_a = room.timeline[room.timeline.length - 1]) === null || _a === void 0 ? void 0 : _a.getTs(),
                userIds: type === types_1.ConversationType.DIRECT
                    ? [this.socialClient.getUserId(), otherId]
                    : room
                        .getMembers()
                        .filter(x => x.membership === 'join')
                        .map(x => x.userId),
                hasMessages: room.timeline.some(event => event.getType() === matrix_js_sdk_1.EventType.RoomMessage),
                name: room.name
            }
        };
    }
    async getProfileInfo(userId) {
        const profile = await this.matrixClient.getProfileInfo(userId);
        return { displayName: profile.displayname, avatarUrl: profile.avatar_url };
    }
    getMemberInfo(roomId, userId) {
        var _a, _b;
        const member = (_a = this.matrixClient.getRoom(roomId)) === null || _a === void 0 ? void 0 : _a.getMember(userId);
        if (!member)
            return {};
        return {
            displayName: member.name,
            avatarUrl: (_b = member.getMxcAvatarUrl()) !== null && _b !== void 0 ? _b : undefined
        };
    }
    /** Get all conversation the user has joined */
    getAllCurrentConversations() {
        const rooms = this.getAllRooms();
        return rooms
            .filter(room => room.getMyMembership() === 'join') // Consider rooms that I have joined
            .map(room => this.getRoomInformation(room));
    }
    /** Get all conversation the user has joined */
    getAllConversationsWithUnreadMessages() {
        return this.getAllCurrentConversations()
            .filter(conv => conv.unreadMessages)
            .map((conv) => conv.conversation);
    }
    /** Get total number of unseen messages from all conversations the user has joined */
    getTotalUnseenMessages() {
        const rooms = this.getAllRooms();
        return rooms
            .filter(room => room.getMyMembership() === 'join') // Consider rooms that I have joined
            .reduce((accumulator, current) => {
            return accumulator + this.getRoomUnreadMessages(current).length;
        }, 0);
    }
    /**
     * Send a message text to a conversation.
     * Returns the message id
     */
    async sendMessageTo(conversationId, message) {
        const { event_id } = await this.matrixClient.sendTextMessage(conversationId, message);
        return event_id;
    }
    /** Mark a message (and all those that came before it on the conversation) as read */
    async markAsRead(conversationId, messageId) {
        let event = (0, Utils_1.findEventInRoom)(this.matrixClient, conversationId, messageId);
        if (!event) {
            // If I couldn't find it locally, then fetch it from the server
            const eventRaw = await this.matrixClient.fetchRoomEvent(conversationId, messageId);
            event = new event_1.MatrixEvent(eventRaw);
        }
        await this.matrixClient.sendReadReceipt(event);
    }
    /** Mark all messages in the conversation as seen */
    async markMessagesAsSeen(conversationId) {
        const room = this.matrixClient.getRoom(conversationId);
        // If there is no room, then there are no messages to mark as read. Anyway, we expect to always be able to get the room,
        // since the method is called when the user opens a conversation.
        if (!room) {
            return;
        }
        const roomMessages = room.timeline.filter(event => event.getType() === matrix_js_sdk_1.EventType.RoomMessage);
        const lastMessage = roomMessages[roomMessages.length - 1].getId();
        await this.markAsRead(conversationId, lastMessage);
    }
    /**
     * Listen to new messages
     */
    onMessage(listener) {
        this.matrixClient.on(room_1.RoomEvent.Timeline, (event, room, toStartOfTimeline, _, data) => {
            if (event.getType() !== 'm.room.message' || // Make sure that it is in fact a message
                event.getContent().msgtype !== types_1.MessageType.TEXT // Make sure that the message is of type text
            ) {
                return;
            }
            // Ignore anything but real-time updates at the end of the room
            if (toStartOfTimeline || !data || !data.liveEvent)
                return;
            // Just listen to the unfiltered timeline, so we don't raise the same message more than once
            if (data.timeline.getFilter())
                return;
            const conversation = {
                type: (0, Utils_1.getConversationTypeFromRoom)(this.matrixClient, room),
                id: room.roomId
            };
            const message = (0, Utils_1.buildTextMessage)(event, types_1.MessageStatus.UNREAD);
            listener(conversation, message);
        });
    }
    /**
     * Listen to updates on the membership of a channel
     * @doc {membership} join | leave | invite
     */
    onChannelMembership(listener) {
        this.matrixClient.on(room_1.RoomEvent.MyMembership, (room, membership) => {
            var _a;
            if (!room || room.getType() !== types_1.CHANNEL_TYPE)
                return; // we only want to know about the updates related to channels
            // Room creators already know about this room
            if (membership === 'join' && this.socialClient.getUserId() === room.getCreator())
                return;
            const nameEvents = room.currentState.getStateEvents(matrix_js_sdk_1.EventType.RoomName);
            const name = (_a = nameEvents[0]) === null || _a === void 0 ? void 0 : _a.getContent()['name'];
            const conversation = this.getRoomInformation(room).conversation;
            conversation.name = name !== null && name !== void 0 ? name : conversation.name;
            listener(conversation, membership);
        });
    }
    /**
     * Listen to updates on the members of a channel
     */
    onChannelMembers(listener) {
        this.matrixClient.on(matrix_js_sdk_1.RoomStateEvent.Members, (_event, state) => {
            const room = this.matrixClient.getRoom(state.roomId);
            if (!room || room.getType() !== types_1.CHANNEL_TYPE)
                return; // we only want to know about the updates related to channels
            const stateMembers = state.getMembers();
            const members = stateMembers.map(member => ({ name: member.name, userId: member.userId }));
            const conversation = this.getRoomInformation(room).conversation;
            listener(conversation, members);
        });
    }
    /**
     * Return basic information about the last read message. Since we don't mark messages sent by me as read,
     * we also check against the last sent message.
     */
    getLastReadMessage(conversationId) {
        // Fetch last message marked as read
        const room = this.matrixClient.getRoom(conversationId);
        const lastReadEventId = room === null || room === void 0 ? void 0 : room.getEventReadUpTo(this.socialClient.getUserId(), false);
        const lastReadMatrixEvent = lastReadEventId
            ? (0, Utils_1.findEventInRoom)(this.matrixClient, conversationId, lastReadEventId)
            : undefined;
        const lastReadEvent = lastReadMatrixEvent ? (0, Utils_1.matrixEventToBasicEventInfo)(lastReadMatrixEvent) : undefined;
        // Fetch last message sent by me
        let lastEventSentByMe;
        const knownLastSentMessage = this.lastSentMessage.get(conversationId);
        if (knownLastSentMessage) {
            lastEventSentByMe = knownLastSentMessage;
        }
        else {
            const timelineSet = (0, Utils_1.getOnlyMessagesSentByMeTimelineSetFromRoom)(this.matrixClient, room);
            const events = timelineSet === null || timelineSet === void 0 ? void 0 : timelineSet.getLiveTimeline().getEvents();
            const lastMatrixEventSentByMe = events ? events[events.length - 1] : undefined;
            if (lastMatrixEventSentByMe) {
                lastEventSentByMe = (0, Utils_1.matrixEventToBasicEventInfo)(lastMatrixEventSentByMe);
                this.lastSentMessage.set(conversationId, lastEventSentByMe);
            }
        }
        // Compare and return the latest
        if (lastReadEvent && lastEventSentByMe) {
            return lastReadEvent.timestamp > lastEventSentByMe.timestamp ? lastReadEvent : lastEventSentByMe;
        }
        else if (lastReadEvent) {
            return lastReadEvent;
        }
        else if (lastEventSentByMe) {
            return lastEventSentByMe;
        }
        return undefined;
    }
    /** Returns a cursor located on the given message. If there is no given message, then it is
     * located at the end of the conversation.
     */
    getCursorOnMessage(conversationId, messageId, options) {
        return ConversationCursor_1.ConversationCursor.build(this.matrixClient, this.socialClient.getUserId(), conversationId, messageId, roomId => this.getLastReadMessage(roomId), options);
    }
    /**
     * Returns a cursor located on the last read message. If no messages were read, then
     * it is located at the end of the conversation.
     */
    getCursorOnLastRead(conversationId, options) {
        const lastReadMessage = this.getLastReadMessage(conversationId);
        return ConversationCursor_1.ConversationCursor.build(this.matrixClient, this.socialClient.getUserId(), conversationId, lastReadMessage === null || lastReadMessage === void 0 ? void 0 : lastReadMessage.id, roomId => this.getLastReadMessage(roomId), options);
    }
    /**
     * Returns a cursor located at the end of the conversation
     */
    getCursorOnLastMessage(conversationId, options) {
        return ConversationCursor_1.ConversationCursor.build(this.matrixClient, this.socialClient.getUserId(), conversationId, undefined, roomId => this.getLastReadMessage(roomId), options);
    }
    /** Get or create a direct conversation with the given user */
    async createDirectConversation(userId) {
        const { conversation, created } = await this.getOrCreateConversation(types_1.ConversationType.DIRECT, [userId]);
        if (created) {
            await this.addDirectRoomToUser(userId, conversation.id);
        }
        return conversation;
    }
    /** Get or create a group conversation with the given users
     * This is a direct conversation between multiple users
     */
    async createGroupConversation(conversationName, userIds) {
        if (userIds.length < 2) {
            throw new Error('Group conversations must include two or more people. ');
        }
        const { conversation } = await this.getOrCreateConversation(types_1.ConversationType.GROUP, userIds, conversationName);
        return conversation;
    }
    /** Get or create a channel with the given users
     * If the channel already exists this will return the channel and won't invite the passed ids
     * If the channel is created, all user ids will be invited to join
     */
    async getOrCreateChannel(channelName, userIds) {
        if (CHANNEL_RESERVED_IDS.includes(channelName.toLocaleLowerCase())) {
            throw new ChannelsError(ChannelErrorKind.RESERVED_NAME);
        }
        if (!validateRegexChannelId(channelName)) {
            throw new ChannelsError(ChannelErrorKind.BAD_REGEX);
        }
        try {
            return this.getOrCreateConversation(types_1.ConversationType.CHANNEL, userIds, channelName, channelName, {
                preset: matrix_js_sdk_1.Preset.PublicChat,
                is_direct: false,
                visibility: matrix_js_sdk_1.Visibility.Public,
                creation_content: {
                    type: types_1.CHANNEL_TYPE
                }
            });
        }
        catch (error) {
            throw new ChannelsError(ChannelErrorKind.GET_OR_CREATE);
        }
    }
    /** Join a channel */
    async joinChannel(roomIdOrChannelAlias) {
        try {
            await this.matrixClient.joinRoom(roomIdOrChannelAlias);
        }
        catch (error) {
            throw new ChannelsError(ChannelErrorKind.JOIN);
        }
    }
    async leaveChannel(roomId) {
        try {
            await this.matrixClient.leave(roomId);
        }
        catch (error) {
            throw new ChannelsError(ChannelErrorKind.LEAVE);
        }
    }
    /** Return whether a conversation has unread messages or not */
    doesConversationHaveUnreadMessages(conversationId) {
        const room = this.matrixClient.getRoom(conversationId);
        return this.doesRoomHaveUnreadMessages(room);
    }
    /** Return a conversation unread messages */
    getConversationUnreadMessages(conversationId) {
        const room = this.matrixClient.getRoom(conversationId);
        return room ? this.getRoomUnreadMessages(room) : [];
    }
    /**
     * Get the conversation for a channel that exists locally, if it doesn't returns undefined
     * @param roomId the roomId of the channel
     */
    getChannel(roomId) {
        const room = this.matrixClient.getRoom(roomId);
        if (!room) {
            return;
        }
        return this.getRoomInformation(room).conversation;
    }
    /**
     * Get the conversation for a channel by its name.
     * @param alias the name of the channel.
     * @returns `Promise<Conversation>` if it exists | `Promise<undefined>` if it does not exist.
     */
    async getChannelByName(alias) {
        try {
            // Try to find it locally
            const room = this.findRoomByAliasLocally(`#${alias}:${this.matrixClient.getDomain()}`);
            if (room) {
                return {
                    id: room.roomId,
                    type: types_1.ConversationType.CHANNEL
                };
            }
            else {
                // Try to find it on the server
                const result = await this.undefinedIfError(() => this.matrixClient.getRoomIdForAlias(`#${alias}:${this.matrixClient.getDomain()}`));
                if (result) {
                    return {
                        id: result.room_id,
                        type: types_1.ConversationType.CHANNEL
                    };
                }
                else {
                    return;
                }
            }
        }
        catch (error) {
            throw new ChannelsError(ChannelErrorKind.GET_OR_CREATE);
        }
    }
    async searchChannel(limit, searchTerm, since) {
        try {
            let publicRooms = [];
            let res;
            let nextBatch = since;
            const filter = searchTerm
                ? {
                    filter: {
                        generic_search_term: searchTerm
                    }
                }
                : {};
            const options = Object.assign({ limit, since: nextBatch }, filter);
            do {
                res = await this.matrixClient.publicRooms(options);
                publicRooms.push(...res.chunk);
                nextBatch = res.next_batch;
            } while (publicRooms.length < limit && res.next_batch);
            return {
                channels: publicRooms.map((room) => ({
                    id: room.room_id,
                    name: room.name,
                    description: room.topic,
                    memberCount: room.num_joined_members,
                    type: types_1.ConversationType.CHANNEL
                })),
                nextBatch
            };
        }
        catch (error) {
            throw new ChannelsError(ChannelErrorKind.SEARCH);
        }
    }
    async assertThatUsersExist(userIds) {
        const unknownUsers = userIds.filter(userId => this.matrixClient.getUser(userId) === null);
        const existsCheck = await Promise.all(unknownUsers.map(async (userId) => [
            userId,
            await this.matrixClient.searchUserDirectory({ term: this.toLocalpart(userId) })
        ]));
        const doesNotExist = existsCheck
            .filter(([, { results }]) => results.length === 0)
            .map(([userId]) => userId);
        if (doesNotExist.length > 0) {
            throw new UnknownUsersError(doesNotExist);
        }
    }
    /**
     * Find or create a conversation for the given other users. There is no need to include the
     * current user id.
     */
    async getOrCreateConversation(type, userIds, conversationName, defaultAlias, createRoomOptions) {
        await this.assertThatUsersExist(userIds);
        const allUsersInConversation = [this.matrixClient.getUserIdLocalpart(), ...userIds];
        const alias = defaultAlias !== null && defaultAlias !== void 0 ? defaultAlias : this.buildAliasForConversationWithUsers(allUsersInConversation);
        let roomId;
        let created;
        // First, try to find the alias locally
        const room = this.findRoomByAliasLocally(`#${alias}:${this.matrixClient.getDomain()}`);
        if (room) {
            roomId = room.roomId;
            created = false;
        }
        else {
            // Try to find alias on the server
            const result = await this.undefinedIfError(() => this.matrixClient.getRoomIdForAlias(`#${alias}:${this.matrixClient.getDomain()}`));
            if (result) {
                roomId = result.room_id;
                created = false;
            }
            else {
                // If alias wasn't found, then create the room
                const creationResult = await this.matrixClient.createRoom(Object.assign({ room_alias_name: alias, preset: matrix_js_sdk_1.Preset.TrustedPrivateChat, is_direct: type === types_1.ConversationType.DIRECT, invite: userIds, name: conversationName }, createRoomOptions));
                roomId = creationResult.room_id;
                created = true;
            }
        }
        return {
            conversation: {
                type,
                id: roomId
            },
            created
        };
    }
    findRoomByAliasLocally(alias) {
        return this.getAllRooms().filter(room => room.getCanonicalAlias() === alias)[0];
    }
    async joinRoom(member) {
        if (!member) {
            return;
        }
        const event = member.events.member;
        const memberContent = event === null || event === void 0 ? void 0 : event.getContent();
        const isDirect = (memberContent === null || memberContent === void 0 ? void 0 : memberContent.membership) === 'invite' && (memberContent === null || memberContent === void 0 ? void 0 : memberContent.is_direct);
        if (event && isDirect) {
            await this.addDirectRoomToUser(event.getSender(), member.roomId);
        }
        await this.matrixClient.joinRoom(member.roomId);
    }
    buildAliasForConversationWithUsers(userIds) {
        if (userIds.length < 2) {
            throw new Error('Conversation must have two users or more.');
        }
        return userIds
            .map(userId => this.toLocalpart(userId))
            .filter((elem, pos, array) => array.indexOf(elem) === pos)
            .sort()
            .join('+');
    }
    toLocalpart(userId) {
        if (!userId.includes(':')) {
            return userId.toLowerCase();
        }
        return userId
            .split(':')[0]
            .substring(1)
            .toLowerCase();
    }
    async undefinedIfError(call) {
        try {
            return await call();
        }
        catch (error) {
            return undefined;
        }
    }
    getAllRooms() {
        return this.matrixClient.getVisibleRooms().filter(room => !room.tags.hasOwnProperty('m.server_notice'));
    }
    async addDirectRoomToUser(userId, roomId) {
        var _a;
        // The documentation specifies that we should store a map from user to direct rooms in the 'm.direct' event
        // However, we only support having one direct room to each user, so the list will only have one element
        const mDirectEvent = this.matrixClient.getAccountData('m.direct');
        const directRoomMap = mDirectEvent ? mDirectEvent.getContent() : {};
        if ((_a = directRoomMap[userId]) === null || _a === void 0 ? void 0 : _a.includes(roomId))
            return;
        directRoomMap[userId] = [roomId];
        await this.matrixClient.setAccountData('m.direct', directRoomMap);
    }
    getRoomUnreadMessages(room) {
        if (!room) {
            return [];
        }
        // Fetch message events
        // this line should use `getOnlyMessagesTimelineSetFromRoom` but there's a bug in the client
        // that for some reason the last message (in real time) it's not always in the `room.getLiveTimeline()`
        // generating a bug where the only unread message is discarded by this function
        const timeline = room.timeline.filter(x => x.getType() === 'm.room.message');
        // If there are no messages, then there are no unread messages
        if (timeline.length === 0) {
            return [];
        }
        const lastReadMessage = this.getLastReadMessage(room.roomId);
        return timeline
            .filter(event => !lastReadMessage || event.getTs() > (lastReadMessage === null || lastReadMessage === void 0 ? void 0 : lastReadMessage.timestamp))
            .map(event => (0, Utils_1.matrixEventToBasicEventInfo)(event));
    }
    doesRoomHaveUnreadMessages(room) {
        return room ? this.getRoomUnreadMessages(room).length > 0 : false;
    }
}
exports.MessagingClient = MessagingClient;
var ChannelErrorKind;
(function (ChannelErrorKind) {
    ChannelErrorKind[ChannelErrorKind["GET_OR_CREATE"] = 0] = "GET_OR_CREATE";
    ChannelErrorKind[ChannelErrorKind["BAD_REGEX"] = 1] = "BAD_REGEX";
    ChannelErrorKind[ChannelErrorKind["RESERVED_NAME"] = 2] = "RESERVED_NAME";
    ChannelErrorKind[ChannelErrorKind["JOIN"] = 3] = "JOIN";
    ChannelErrorKind[ChannelErrorKind["LEAVE"] = 4] = "LEAVE";
    ChannelErrorKind[ChannelErrorKind["SEARCH"] = 5] = "SEARCH";
})(ChannelErrorKind = exports.ChannelErrorKind || (exports.ChannelErrorKind = {}));
class ChannelsError extends Error {
    constructor(kind) {
        super(`Failed to interact with channel: ${kind}`);
        this.kind = kind;
    }
    getKind() {
        return this.kind;
    }
}
exports.ChannelsError = ChannelsError;
class UnknownUsersError extends Error {
    constructor(unknownUsers) {
        super(`Some of the given users are not part of the system: '${unknownUsers.join(', ')}'`);
        this.unknownUsers = unknownUsers;
    }
    getUnknownUsers() {
        return this.unknownUsers;
    }
}
exports.UnknownUsersError = UnknownUsersError;
//# sourceMappingURL=MessagingClient.js.map