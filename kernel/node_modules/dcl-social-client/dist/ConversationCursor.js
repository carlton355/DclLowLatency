"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationCursor = void 0;
const timeline_window_1 = require("matrix-js-sdk/lib/timeline-window");
const event_timeline_1 = require("matrix-js-sdk/lib/models/event-timeline");
const Utils_1 = require("./Utils");
const types_1 = require("./types");
/**
 * This class can be used to navigate a conversation's history. You can load more messages
 * by moving forwards or backwards in time.
 */
class ConversationCursor {
    constructor(roomId, window, lastReadMessageTimestampFetch) {
        this.roomId = roomId;
        this.window = window;
        this.lastReadMessageTimestampFetch = lastReadMessageTimestampFetch;
    }
    getMessages() {
        var _a;
        const latestReadTimestamp = (_a = this.lastReadMessageTimestampFetch(this.roomId)) === null || _a === void 0 ? void 0 : _a.timestamp;
        const events = this.window.getEvents();
        return events.map(event => (0, Utils_1.buildTextMessage)(event, latestReadTimestamp && event.getTs() <= latestReadTimestamp ? types_1.MessageStatus.READ : types_1.MessageStatus.UNREAD));
    }
    canExtendInDirection(direction) {
        const newDirection = direction === types_1.CursorDirection.BACKWARDS ? event_timeline_1.EventTimeline.BACKWARDS : event_timeline_1.EventTimeline.FORWARDS;
        return this.window.canPaginate(newDirection);
    }
    /**
     * Tries to extend the cursor in the provided direction, by adding 'size' events.
     * If doing so would break the cursor limit, then will remove the extra messages at the other side of the cursor.
     * Returns true if more messages were actually added to the cursor.
     */
    moveInDirection(direction, size) {
        const newDirection = direction === types_1.CursorDirection.BACKWARDS ? event_timeline_1.EventTimeline.BACKWARDS : event_timeline_1.EventTimeline.FORWARDS;
        return this.window.paginate(newDirection, size);
    }
    /**
     * Remove 'numberOfEvents' events from the cursor. If oldestMessages is true, then we will remove the
     * oldest messages. If it is false, we will remove the newest messages.
     */
    removeFromCursor(numberOfEvents, oldestMessages) {
        this.window.unpaginate(numberOfEvents, oldestMessages);
    }
    static async build(client, userId, roomId, initialEventId, // If no eventId is set, then we will start at the last message
    lastReadMessageTimestampFetch, options) {
        var _a;
        try {
            const limit = ConversationCursor.calculateLimit(options);
            const initialSize = (_a = options === null || options === void 0 ? void 0 : options.initialSize) !== null && _a !== void 0 ? _a : this.DEFAULT_INITIAL_SIZE;
            let room = client.getRoom(roomId);
            let retries = 0;
            while (!room && retries < 3) {
                retries++;
                await (0, Utils_1.waitForNextSync)(client);
                room = client.getRoom(roomId);
            }
            if (!room)
                return;
            const timelineSet = (0, Utils_1.getOnlyMessagesTimelineSetFromRoom)(userId, room, limit);
            const window = new timeline_window_1.TimelineWindow(client, timelineSet, { windowLimit: limit });
            await window.load(initialEventId, initialSize);
            // It could happen that the initial size of the window isn't respected. That's why we will try to fix it
            let windowSize = window.getEvents().length;
            let gotResults = true;
            while (windowSize < initialSize && gotResults) {
                gotResults = await window.paginate(event_timeline_1.EventTimeline.BACKWARDS, initialSize - windowSize);
                windowSize = window.getEvents().length;
            }
            gotResults = true;
            while (windowSize < initialSize && gotResults) {
                gotResults = await window.paginate(event_timeline_1.EventTimeline.FORWARDS, initialSize - windowSize);
                windowSize = window.getEvents().length;
            }
            return new ConversationCursor(roomId, window, lastReadMessageTimestampFetch);
        }
        catch (err) {
            return;
        }
    }
    static calculateLimit(options) {
        if (options === null || options === void 0 ? void 0 : options.limit) {
            return options.limit;
        }
        if ((options === null || options === void 0 ? void 0 : options.initialSize) && options.initialSize > ConversationCursor.DEFAULT_LIMIT) {
            return options.initialSize;
        }
        return ConversationCursor.DEFAULT_LIMIT;
    }
}
exports.ConversationCursor = ConversationCursor;
ConversationCursor.DEFAULT_LIMIT = 30;
ConversationCursor.DEFAULT_INITIAL_SIZE = 20;
//# sourceMappingURL=ConversationCursor.js.map