import { RpcClientPort } from '@dcl/rpc/dist/types';
import { FlatFetchInit } from '@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen';
export declare type OriginalFlatFetchResponse = {
    ok: boolean;
    status: number;
    statusText: string;
    headers: Record<string, string>;
    json?: any;
    text?: string;
};
export declare type BodyType = 'json' | 'text';
export declare type OriginalFlatFetchInit = RequestInit & {
    responseBodyType?: BodyType;
};
export declare namespace SignedFetchServiceClient {
    function create<Context extends {}>(clientPort: RpcClientPort): import("@dcl/rpc/dist/codegen-types").RawClient<import("@dcl/rpc/dist/codegen-types").FromTsProtoServiceDefinition<{
        readonly name: "SignedFetchService";
        readonly fullName: "decentraland.kernel.apis.SignedFetchService";
        readonly methods: {
            readonly signedFetch: {
                readonly name: "SignedFetch";
                readonly requestType: {
                    encode(message: import("@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen").SignedFetchRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                    decode(input: Uint8Array | import("protobufjs").Reader, length?: number | undefined): import("@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen").SignedFetchRequest;
                    fromJSON(object: any): import("@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen").SignedFetchRequest;
                    toJSON(message: import("@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen").SignedFetchRequest): unknown;
                    fromPartial<I extends {
                        url?: string | undefined;
                        init?: {
                            method?: string | undefined;
                            body?: string | undefined;
                            headers?: {
                                [x: string]: string | undefined;
                            } | undefined;
                        } | undefined;
                    } & {
                        url?: string | undefined;
                        init?: ({
                            method?: string | undefined;
                            body?: string | undefined;
                            headers?: {
                                [x: string]: string | undefined;
                            } | undefined;
                        } & {
                            method?: string | undefined;
                            body?: string | undefined;
                            headers?: ({
                                [x: string]: string | undefined;
                            } & {
                                [x: string]: string | undefined;
                            } & { [K in Exclude<keyof I["init"]["headers"], string | number>]: never; }) | undefined;
                        } & { [K_1 in Exclude<keyof I["init"], keyof FlatFetchInit>]: never; }) | undefined;
                    } & { [K_2 in Exclude<keyof I, keyof import("@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen").SignedFetchRequest>]: never; }>(object: I): import("@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen").SignedFetchRequest;
                };
                readonly requestStream: false;
                readonly responseType: {
                    encode(message: import("@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen").FlatFetchResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                    decode(input: Uint8Array | import("protobufjs").Reader, length?: number | undefined): import("@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen").FlatFetchResponse;
                    fromJSON(object: any): import("@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen").FlatFetchResponse;
                    toJSON(message: import("@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen").FlatFetchResponse): unknown;
                    fromPartial<I_1 extends {
                        ok?: boolean | undefined;
                        status?: number | undefined;
                        statusText?: string | undefined;
                        headers?: {
                            [x: string]: string | undefined;
                        } | undefined;
                        body?: string | undefined;
                    } & {
                        ok?: boolean | undefined;
                        status?: number | undefined;
                        statusText?: string | undefined;
                        headers?: ({
                            [x: string]: string | undefined;
                        } & {
                            [x: string]: string | undefined;
                        } & { [K_3 in Exclude<keyof I_1["headers"], string | number>]: never; }) | undefined;
                        body?: string | undefined;
                    } & { [K_4 in Exclude<keyof I_1, keyof import("@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen").FlatFetchResponse>]: never; }>(object: I_1): import("@dcl/protocol/out-ts/decentraland/kernel/apis/signed_fetch.gen").FlatFetchResponse;
                };
                readonly responseStream: false;
                readonly options: {};
            };
        };
    }>, Context>;
    function createLegacy<Context extends {}>(clientPort: RpcClientPort): {
        signedFetch(url: string, originalInit?: OriginalFlatFetchInit): Promise<OriginalFlatFetchResponse>;
    };
}
