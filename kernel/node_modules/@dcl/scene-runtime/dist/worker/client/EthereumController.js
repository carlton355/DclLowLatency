"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumControllerServiceClient = void 0;
const codegen = __importStar(require("@dcl/rpc/dist/codegen"));
const ethereum_controller_gen_1 = require("@dcl/protocol/out-ts/decentraland/kernel/apis/ethereum_controller.gen");
var EthereumControllerServiceClient;
(function (EthereumControllerServiceClient) {
    function create(clientPort) {
        return codegen.loadService(clientPort, ethereum_controller_gen_1.EthereumControllerServiceDefinition);
    }
    EthereumControllerServiceClient.create = create;
    function createLegacy(clientPort) {
        const originalService = codegen.loadService(clientPort, ethereum_controller_gen_1.EthereumControllerServiceDefinition);
        return {
            ...originalService,
            /**
             * Requires a generic payment in ETH or ERC20.
             * @param  {string} [toAddress] - NFT asset id.
             * @param  {number} [amount] - Exact amount of the order.
             * @param  {string} [currency] - ETH or ERC20 supported token symbol
             */
            async requirePayment(toAddress, amount, currency) {
                const response = await originalService.requirePayment({ toAddress, amount, currency });
                return JSON.parse(response.jsonAnyResponse);
            },
            /**
             * Takes a dictionary, converts it to string with correct format and signs it.
             * @param  {messageToSign} [MessageDict] - Message in an object format.
             * @return {object} - Promise of message and signature in an object.
             */
            async signMessage(message) {
                return await originalService.signMessage({ message });
            },
            /**
             * Takes a message string, parses it and converts to object.
             * @param  {message} [string] - Message in a string format.
             * @return {object} - Promise of message as a MessageDict.
             * @internal
             */
            async convertMessageToObject(message) {
                return (await originalService.convertMessageToObject({ message })).dict;
            },
            /**
             * Used to build a Ethereum provider
             */
            async sendAsync(message) {
                return JSON.parse((await originalService.sendAsync({
                    id: message.id,
                    method: message.method,
                    jsonParams: JSON.stringify(message.params)
                })).jsonAnyResponse);
            },
            /**
             * Returns the user's public key (address)
             */
            async getUserAccount() {
                return (await originalService.getUserAccount({})).address;
            }
        };
    }
    EthereumControllerServiceClient.createLegacy = createLegacy;
})(EthereumControllerServiceClient = exports.EthereumControllerServiceClient || (exports.EthereumControllerServiceClient = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXRoZXJldW1Db250cm9sbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3dvcmtlci9jbGllbnQvRXRoZXJldW1Db250cm9sbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsK0RBQWdEO0FBRWhELG1IQUEySDtBQWEzSCxJQUFpQiwrQkFBK0IsQ0F3RS9DO0FBeEVELFdBQWlCLCtCQUErQjtJQUM5QyxTQUFnQixNQUFNLENBQXFCLFVBQXlCO1FBQ2xFLE9BQU8sT0FBTyxDQUFDLFdBQVcsQ0FDeEIsVUFBVSxFQUNWLDZEQUFtQyxDQUNwQyxDQUFBO0lBQ0gsQ0FBQztJQUxlLHNDQUFNLFNBS3JCLENBQUE7SUFFRCxTQUFnQixZQUFZLENBQXFCLFVBQXlCO1FBQ3hFLE1BQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQ3pDLFVBQVUsRUFDViw2REFBbUMsQ0FDcEMsQ0FBQTtRQUVELE9BQU87WUFDTCxHQUFHLGVBQWU7WUFFbEI7Ozs7O2VBS0c7WUFDSCxLQUFLLENBQUMsY0FBYyxDQUFDLFNBQWlCLEVBQUUsTUFBYyxFQUFFLFFBQWdCO2dCQUN0RSxNQUFNLFFBQVEsR0FBRyxNQUFNLGVBQWUsQ0FBQyxjQUFjLENBQUMsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUE7Z0JBQ3RGLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUE7WUFDN0MsQ0FBQztZQUVEOzs7O2VBSUc7WUFDSCxLQUFLLENBQUMsV0FBVyxDQUNmLE9BQW9CO2dCQUVwQixPQUFPLE1BQU0sZUFBZSxDQUFDLFdBQVcsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUE7WUFDdkQsQ0FBQztZQUVEOzs7OztlQUtHO1lBQ0gsS0FBSyxDQUFDLHNCQUFzQixDQUFDLE9BQWU7Z0JBQzFDLE9BQU8sQ0FBQyxNQUFNLGVBQWUsQ0FBQyxzQkFBc0IsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUE7WUFDekUsQ0FBQztZQUVEOztlQUVHO1lBQ0gsS0FBSyxDQUFDLFNBQVMsQ0FBQyxPQUEyQjtnQkFDekMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUNmLENBQ0UsTUFBTSxlQUFlLENBQUMsU0FBUyxDQUFDO29CQUM5QixFQUFFLEVBQUUsT0FBTyxDQUFDLEVBQUU7b0JBQ2QsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUFNO29CQUN0QixVQUFVLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDO2lCQUMzQyxDQUFDLENBQ0gsQ0FBQyxlQUFlLENBQ2xCLENBQUE7WUFDSCxDQUFDO1lBRUQ7O2VBRUc7WUFDSCxLQUFLLENBQUMsY0FBYztnQkFDbEIsT0FBTyxDQUFDLE1BQU0sZUFBZSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQVEsQ0FBQTtZQUM1RCxDQUFDO1NBQ0YsQ0FBQTtJQUNILENBQUM7SUEvRGUsNENBQVksZUErRDNCLENBQUE7QUFDSCxDQUFDLEVBeEVnQiwrQkFBK0IsR0FBL0IsdUNBQStCLEtBQS9CLHVDQUErQixRQXdFL0MifQ==