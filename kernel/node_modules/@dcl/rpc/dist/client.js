"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRpcClient = exports.streamFromDispatcher = exports.createPort = void 0;
const mitt_1 = __importDefault(require("mitt"));
const minimal_1 = require("protobufjs/minimal");
const protocol_1 = require("./protocol");
const message_number_handler_1 = require("./message-number-handler");
const push_channel_1 = require("./push-channel");
const helpers_1 = require("./protocol/helpers");
const EMPTY_U8 = new Uint8Array(0);
// @internal
function createPort(portId, portName, dispatcher) {
    const events = (0, mitt_1.default)();
    let state = "open";
    events.on("close", () => {
        state = "closed";
    });
    return {
        ...events,
        portName,
        portId,
        get state() {
            return state;
        },
        close() {
            const bb = new minimal_1.Writer();
            protocol_1.DestroyPort.encode({
                messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_DESTROY_PORT, 0),
                portId,
            }, bb);
            dispatcher.transport.sendMessage(bb.finish());
            events.emit("close", {});
        },
        async loadModule(moduleName) {
            const ret = await dispatcher.request((bb, messageNumber) => {
                protocol_1.RequestModule.encode({
                    messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE, messageNumber),
                    moduleName,
                    portId,
                }, bb);
            });
            const parsedMessage = (0, helpers_1.parseProtocolMessage)(ret);
            if (parsedMessage) {
                const [messageType, message] = parsedMessage;
                if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE) {
                    const ret = {};
                    for (let procedure of message.procedures) {
                        ret[procedure.procedureName] = createProcedure(portId, procedure.procedureId, dispatcher);
                    }
                    return ret;
                }
                else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE) {
                    throwIfRemoteError(message);
                }
            }
            throw new Error("Unknown response received from server.");
        },
    };
}
exports.createPort = createPort;
function throwIfRemoteError(parsedMessage) {
    throw new Error("RemoteError: " + parsedMessage.errorMessage);
}
/**
 * If a StreamMessage is received, then it means we have the POSSIBILITY to
 * consume a remote generator. The client must answer every ACK with the next
 * inteded action, could be: next(), close(). Both actions are serialized in the
 * StreamMessage. The server MUST NOT generate any new element of the generator
 * if the client doesn't ask for it.
 *
 * The whole protocol is designed to be SLOW AND SECURE, that means, ACKs (slow)
 * will block the generation and consumption of iterators (secure).
 *
 * That exist to save the memory of the servers and to generate the much needed
 * backpressure.
 *
 * If throughput is what you are looking for, you may better use bigger messages
 * containing serialized lists. Effectively reducing the number of messages
 * and increasing their size.
 *
 * @internal
 */
function streamFromDispatcher(dispatcher, streamMessage, messageNumber) {
    let lastReceivedSequenceId = 0;
    let isRemoteClosed = false;
    const channel = new push_channel_1.AsyncQueue(sendServerSignals);
    dispatcher.transport.on("close", () => {
        channel.close(new Error("RPC Transport closed"));
    });
    dispatcher.transport.on("error", () => {
        channel.close(new Error("RPC Transport failed"));
    });
    // This function is called at two moments
    // 1. When the channel is closed or fails -> an ACK closing the stream is sent to the server
    // 2. When the channel.next() is called   -> an ACK requesting the next elem is sent to the server
    function sendServerSignals(_channel, action) {
        if (action == "close") {
            dispatcher.removeListener(messageNumber);
        }
        if (!isRemoteClosed) {
            if (action == "close") {
                dispatcher.transport.sendMessage((0, helpers_1.closeStreamMessage)(messageNumber, lastReceivedSequenceId, streamMessage.portId));
            }
            else if (action == "next") {
                dispatcher.transport.sendMessage((0, helpers_1.streamAckMessage)(messageNumber, lastReceivedSequenceId, streamMessage.portId));
            }
        }
    }
    // receive a message from the server and send it to the iterable channel
    function processMessage(message) {
        lastReceivedSequenceId = message.sequenceId;
        if (message.closed) {
            // when the server CLOSES the stream, then we raise the flag isRemoteClosed
            // to prevent sending an extra closeStreamMessage to the server after closing
            // our channel.
            // IMPORTANT: If the server closes the connection, then we DONT send the ACK
            //            back to the server because it is redundant information.
            isRemoteClosed = true;
            channel.close();
        }
        else {
            channel.enqueue(message.payload);
        }
    }
    dispatcher.addListener(messageNumber, (reader) => {
        const ret = (0, helpers_1.parseProtocolMessage)(reader);
        if (ret) {
            const [messageType, message] = ret;
            if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE) {
                processMessage(message);
            }
            else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE) {
                isRemoteClosed = true;
                channel.close(new Error("RemoteError: " + (message.errorMessage || "Unknown remote error")));
            }
            else {
                channel.close(new Error("RemoteError: Protocol error"));
            }
        }
        else {
            channel.close(new Error("RemoteError: Protocol error"));
        }
    });
    return channel;
}
exports.streamFromDispatcher = streamFromDispatcher;
// @internal
function createProcedure(portId, procedureId, dispatcher) {
    const callProcedurePacket = {
        portId,
        messageIdentifier: 0,
        payload: EMPTY_U8,
        procedureId,
    };
    return async function (data) {
        if (data) {
            callProcedurePacket.payload = data;
        }
        else {
            callProcedurePacket.payload = EMPTY_U8;
        }
        const ret = (0, helpers_1.parseProtocolMessage)(await dispatcher.request((bb, messageNumber) => {
            callProcedurePacket.messageIdentifier = (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST, messageNumber);
            protocol_1.Request.encode(callProcedurePacket, bb);
        }));
        if (ret) {
            const [messageType, message, messageNumber] = ret;
            if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_RESPONSE) {
                const u8 = message.payload;
                if (u8.length) {
                    return u8;
                }
                else {
                    return undefined;
                }
            }
            else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE) {
                // If a StreamMessage is received, then it means we have the POSSIBILITY
                // to consume a remote generator. Look into the streamFromDispatcher functions
                // for more information.
                return streamFromDispatcher(dispatcher, message, messageNumber);
            }
            else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE) {
                throwIfRemoteError(message);
            }
        }
    };
}
/**
 * @public
 */
async function createRpcClient(transport) {
    const clientPortByName = new Map();
    const dispatcher = (0, message_number_handler_1.messageNumberHandler)(transport);
    async function internalCreatePort(portName) {
        const ret = await dispatcher.request((bb, messageNumber) => {
            protocol_1.CreatePort.encode({
                messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT, messageNumber),
                portName,
            }, bb);
        });
        const parsedMessage = (0, helpers_1.parseProtocolMessage)(ret);
        if (parsedMessage) {
            const [messageType, message] = parsedMessage;
            if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE) {
                const portId = message.portId;
                return createPort(portId, portName, dispatcher);
            }
            else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE) {
                throwIfRemoteError(message);
            }
        }
        throw new Error("Unknown response received from server.");
    }
    // wait for transport to be connected
    await new Promise((resolve, reject) => {
        transport.on("connect", resolve);
        transport.on("error", reject);
    });
    return {
        // the only objective of this function is to deduplicate asynchronous calls
        // and produce an idempotent module load
        async createPort(portName) {
            if (clientPortByName.has(portName)) {
                return clientPortByName.get(portName);
            }
            const portFuture = internalCreatePort(portName);
            clientPortByName.set(portName, portFuture);
            const port = await portFuture;
            transport.on("close", () => {
                port.close();
            });
            port.on("close", () => {
                if (clientPortByName.get(portName) === portFuture) {
                    clientPortByName.delete(portName);
                }
            });
            return port;
        },
    };
}
exports.createRpcClient = createRpcClient;
//# sourceMappingURL=client.js.map