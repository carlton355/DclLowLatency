"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAckHelper = void 0;
const minimal_1 = require("protobufjs/minimal");
const helpers_1 = require("./protocol/helpers");
const protocol_1 = require("./protocol");
function createAckHelper(transport) {
    const oneTimeCallbacks = new Map();
    const bb = new minimal_1.Writer();
    function closeAll() {
        oneTimeCallbacks.forEach(([resolve]) => resolve({ closed: true, ack: false }));
        oneTimeCallbacks.clear();
    }
    transport.on("close", closeAll);
    transport.on("error", (err) => {
        oneTimeCallbacks.forEach(([, reject]) => reject(err));
        oneTimeCallbacks.clear();
    });
    return {
        receiveAck(data, messageNumber) {
            const key = `${messageNumber},${data.sequenceId}`;
            const fut = oneTimeCallbacks.get(key);
            if (fut) {
                oneTimeCallbacks.delete(key);
                fut[0](data);
            }
            else {
                throw new Error("Received a message for an inexistent handler " + key);
            }
        },
        async sendWithAck(data) {
            const [_, messageNumber] = (0, helpers_1.parseMessageIdentifier)(data.messageIdentifier);
            const key = `${messageNumber},${data.sequenceId}`;
            const ret = new Promise(function ackPromise(ret, rej) {
                oneTimeCallbacks.set(key, [ret, rej]);
            });
            bb.reset();
            protocol_1.StreamMessage.encode(data, bb);
            transport.sendMessage(bb.finish());
            return ret;
        },
    };
}
exports.createAckHelper = createAckHelper;
//# sourceMappingURL=ack-helper.js.map