import { Writer, Reader } from "protobufjs/minimal";
export declare type CallOptions = {};
export declare type MethodRequest<Definition extends MethodDefinition<any, any>> = Definition extends MethodDefinition<infer T, any, any, any> ? T : never;
export declare type MethodResponse<Definition extends MethodDefinition<any, any>> = Definition extends MethodDefinition<any, infer T, any, any> ? T : never;
export declare type TsProtoServiceDefinition = {
    name: string;
    fullName: string;
    methods: {
        [method: string]: TsProtoMethodDefinition<any, any>;
    };
};
export declare type TsProtoMethodDefinition<Request, Response> = {
    name: string;
    requestType: TsProtoMessageType<Request>;
    requestStream: boolean;
    responseType: TsProtoMessageType<Response>;
    responseStream: boolean;
    options: {
        idempotencyLevel?: "IDEMPOTENT" | "NO_SIDE_EFFECTS";
    };
};
export interface TsProtoMessageType<T> {
    encode(message: T, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
}
export declare type ProtobufJsWriter = {
    finish(): Uint8Array;
};
export declare type TsProtoMessageIn<Type extends TsProtoMessageType<any>> = Type["encode"] extends Function ? Parameters<Type["encode"]>[0] : Type extends TsProtoMessageType<infer Message> ? Message : never;
export declare type FromTsProtoServiceDefinition<Service extends TsProtoServiceDefinition> = {
    [M in keyof Service["methods"]]: FromTsProtoMethodDefinition<Service["methods"][M]>;
};
export declare type FromTsProtoMethodDefinition<Method> = Method extends TsProtoMethodDefinition<infer Request, infer Response> ? MethodDefinition<TsProtoMessageIn<Method["requestType"]>, TsProtoMessageIn<Method["responseType"]>, Method["requestStream"], Method["responseStream"]> : never;
export declare type ServiceDefinition = {
    [method: string]: AnyMethodDefinition;
};
export declare type MethodDefinition<Request, Response, RequestStream extends boolean = boolean, ResponseStream extends boolean = boolean> = {
    path: string;
    requestStream: RequestStream;
    responseStream: ResponseStream;
    requestSerialize(value: Request): Uint8Array;
    requestDeserialize(bytes: Uint8Array): Request;
    responseSerialize(value: Response): Uint8Array;
    options: {
        idempotencyLevel?: "IDEMPOTENT" | "NO_SIDE_EFFECTS";
    };
};
export declare type AnyMethodDefinition = MethodDefinition<any, any>;
export declare type Client<Service extends TsProtoServiceDefinition, CallOptionsExt = {}> = RawClient<FromTsProtoServiceDefinition<Service>, CallOptionsExt>;
export declare type RawClient<Service extends ServiceDefinition, CallOptionsExt = {}> = {
    [Method in keyof Service]: ClientMethod<Service[Method], CallOptionsExt>;
};
export declare type ClientMethod<Definition extends MethodDefinition<any, any, any, any>, CallOptionsExt = {}> = Definition["requestStream"] extends false ? Definition["responseStream"] extends false ? UnaryClientMethod<MethodRequest<Definition>, MethodResponse<Definition>, CallOptionsExt> : Definition["responseStream"] extends true ? ServerStreamingClientMethod<MethodRequest<Definition>, MethodResponse<Definition>, CallOptionsExt> : never : Definition["requestStream"] extends true ? Definition["responseStream"] extends false ? ClientStreamingClientMethod<MethodRequest<Definition>, MethodResponse<Definition>, CallOptionsExt> : Definition["responseStream"] extends true ? BidiStreamingClientMethod<MethodRequest<Definition>, MethodResponse<Definition>, CallOptionsExt> : never : never;
export declare type UnaryClientMethod<Request, Response, CallOptionsExt = {}> = (request: Request, options?: CallOptions & CallOptionsExt) => Promise<Response>;
export declare type ServerStreamingClientMethod<Request, Response, CallOptionsExt = {}> = (request: Request, options?: CallOptions & CallOptionsExt) => AsyncGenerator<Response>;
export declare type ClientStreamingClientMethod<Request, Response, CallOptionsExt = {}> = (request: AsyncIterable<Request>, options?: CallOptions & CallOptionsExt) => Promise<Response>;
export declare type BidiStreamingClientMethod<Request, Response, CallOptionsExt = {}> = (request: AsyncIterable<Request>, options?: CallOptions & CallOptionsExt) => AsyncGenerator<Response>;
export declare type RawServiceImplementation<Service extends ServiceDefinition, CallContextExt> = {
    [Method in keyof Service]: MethodImplementation<Service[Method], CallContextExt>;
};
export declare type MethodImplementation<Definition extends MethodDefinition<any, any, any, any>, CallContextExt> = Definition["requestStream"] extends false ? Definition["responseStream"] extends false ? UnaryMethodImplementation<MethodRequest<Definition>, MethodResponse<Definition>, CallContextExt> : Definition["responseStream"] extends true ? ServerStreamingMethodImplementation<MethodRequest<Definition>, MethodResponse<Definition>, CallContextExt> : never : Definition["requestStream"] extends true ? Definition["responseStream"] extends false ? ClientStreamingMethodImplementation<MethodRequest<Definition>, MethodResponse<Definition>, CallContextExt> : Definition["responseStream"] extends true ? BidiStreamingMethodImplementation<MethodRequest<Definition>, MethodResponse<Definition>, CallContextExt> : never : never;
export declare type UnaryMethodImplementation<Request, Response, CallContextExt> = (request: Request, context: CallContextExt) => Promise<Response>;
export declare type ServerStreamingMethodImplementation<Request, Response, CallContextExt> = (request: Request, context: CallContextExt) => ServerStreamingMethodResult<Response>;
export declare type ClientStreamingMethodImplementation<Request, Response, CallContextExt> = (request: AsyncIterable<Request>, context: CallContextExt) => Promise<Response>;
export declare type BidiStreamingMethodImplementation<Request, Response, CallContextExt> = (request: AsyncIterable<Request>, context: CallContextExt) => ServerStreamingMethodResult<Response>;
export declare type ServerStreamingMethodResult<Response> = {
    [Symbol.asyncIterator](): AsyncGenerator<Response, void>;
};
//# sourceMappingURL=codegen-types.d.ts.map