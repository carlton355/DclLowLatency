var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var lastGeneratedId = 0;
/**
 * Log function. Only works in debug mode, otherwise it does nothing.
 * @param args - any loggable parameter
 * @public
 */
export function log() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (typeof dcl !== 'undefined') {
        dcl.log.apply(dcl, __spreadArray([], __read(args), false));
    }
    else {
        console.log.apply(console, __spreadArray(['DEBUG:'], __read(args), false));
    }
}
/**
 * Error function. Prints a console error. Only works in debug mode, otherwise it does nothing.
 * @param error - string or Error object.
 * @param data - any debug information.
 * @public
 */
export function error(error, data) {
    if (typeof dcl !== 'undefined') {
        dcl.error(error, data);
    }
    else {
        console.error('ERROR:', error, data);
    }
}
/**
 * Generates a new prefixed id
 * @public
 */
export function newId(type) {
    lastGeneratedId++;
    if (type.length === 0)
        throw new Error('newId(type: string): type cannot be empty');
    return type + lastGeneratedId.toString(36);
}
/**
 * @internal
 */
export function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0;
        var v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
/**
 * Returns an array of the given size filled with element built from the given constructor and the paramters
 * @param size - the number of element to construct and put in the array
 * @param itemBuilder - a callback responsible for creating new instance of item. Called once per array entry.
 * @returns a new array filled with new objects
 * @internal
 */
export function buildArray(size, itemBuilder) {
    var a = [];
    for (var i = 0; i < size; ++i) {
        a.push(itemBuilder());
    }
    return a;
}
/**
 * @public
 */
export function openExternalURL(url) {
    if (typeof dcl !== 'undefined') {
        dcl.openExternalUrl(url);
    }
    else {
        error('ERROR: openExternalURL dcl is undefined');
    }
}
/**
 * Popup NFT info dialog
 * @param scr - 'ethereum://contractAddress/tokenID'
 * @param comment - optional. add a comment.
 * @public
 */
export function openNFTDialog(scr, comment) {
    if (comment === void 0) { comment = null; }
    if (typeof dcl !== 'undefined') {
        var regex = /ethereum:\/\/(.+)\/(.+)/;
        var matches = scr.match(regex);
        if (!matches || matches.length < 3) {
            return;
        }
        dcl.openNFTDialog(matches[1], matches[2], comment);
    }
    else {
        error('ERROR: openNFTDialog dcl is undefined');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lY3MvaGVscGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFBO0FBSXZCOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsR0FBRztJQUFDLGNBQWM7U0FBZCxVQUFjLEVBQWQscUJBQWMsRUFBZCxJQUFjO1FBQWQseUJBQWM7O0lBQ2hDLElBQUksT0FBTyxHQUFHLEtBQUssV0FBVyxFQUFFO1FBQzlCLEdBQUcsQ0FBQyxHQUFHLE9BQVAsR0FBRywyQkFBUSxJQUFJLFdBQUM7S0FDakI7U0FBTTtRQUNMLE9BQU8sQ0FBQyxHQUFHLE9BQVgsT0FBTyxpQkFBSyxRQUFRLFVBQUssSUFBSSxXQUFDO0tBQy9CO0FBQ0gsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLEtBQUssQ0FBQyxLQUFxQixFQUFFLElBQVU7SUFDckQsSUFBSSxPQUFPLEdBQUcsS0FBSyxXQUFXLEVBQUU7UUFDOUIsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFZLEVBQUUsSUFBSSxDQUFDLENBQUE7S0FDOUI7U0FBTTtRQUNMLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQTtLQUNyQztBQUNILENBQUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsS0FBSyxDQUFDLElBQVk7SUFDaEMsZUFBZSxFQUFFLENBQUE7SUFDakIsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUM7UUFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFBO0lBQzlELE9BQU8sSUFBSSxHQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUE7QUFDNUMsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLElBQUk7SUFDbEIsT0FBTyxzQ0FBc0MsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQztRQUN4RSxJQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUE7UUFDbEMsSUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUE7UUFDekMsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFBO0lBQ3ZCLENBQUMsQ0FBQyxDQUFBO0FBQ0osQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxVQUFVLENBQUksSUFBWSxFQUFFLFdBQW9CO0lBQzlELElBQU0sQ0FBQyxHQUFRLEVBQUUsQ0FBQTtJQUNqQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1FBQzdCLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQTtLQUN0QjtJQUNELE9BQU8sQ0FBQyxDQUFBO0FBQ1YsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLGVBQWUsQ0FBQyxHQUFXO0lBQ3pDLElBQUksT0FBTyxHQUFHLEtBQUssV0FBVyxFQUFFO1FBQzlCLEdBQUcsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUE7S0FDekI7U0FBTTtRQUNMLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFBO0tBQ2pEO0FBQ0gsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLGFBQWEsQ0FBQyxHQUFXLEVBQUUsT0FBNkI7SUFBN0Isd0JBQUEsRUFBQSxjQUE2QjtJQUN0RSxJQUFJLE9BQU8sR0FBRyxLQUFLLFdBQVcsRUFBRTtRQUM5QixJQUFNLEtBQUssR0FBRyx5QkFBeUIsQ0FBQTtRQUN2QyxJQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFBO1FBRWhDLElBQUksQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDbEMsT0FBTTtTQUNQO1FBRUQsR0FBRyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFBO0tBQ25EO1NBQU07UUFDTCxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQTtLQUMvQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgbGFzdEdlbmVyYXRlZElkID0gMFxuXG5kZWNsYXJlIGxldCBjb25zb2xlOiBhbnlcblxuLyoqXG4gKiBMb2cgZnVuY3Rpb24uIE9ubHkgd29ya3MgaW4gZGVidWcgbW9kZSwgb3RoZXJ3aXNlIGl0IGRvZXMgbm90aGluZy5cbiAqIEBwYXJhbSBhcmdzIC0gYW55IGxvZ2dhYmxlIHBhcmFtZXRlclxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gbG9nKC4uLmFyZ3M6IGFueVtdKSB7XG4gIGlmICh0eXBlb2YgZGNsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRjbC5sb2coLi4uYXJncylcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZygnREVCVUc6JywgLi4uYXJncylcbiAgfVxufVxuXG4vKipcbiAqIEVycm9yIGZ1bmN0aW9uLiBQcmludHMgYSBjb25zb2xlIGVycm9yLiBPbmx5IHdvcmtzIGluIGRlYnVnIG1vZGUsIG90aGVyd2lzZSBpdCBkb2VzIG5vdGhpbmcuXG4gKiBAcGFyYW0gZXJyb3IgLSBzdHJpbmcgb3IgRXJyb3Igb2JqZWN0LlxuICogQHBhcmFtIGRhdGEgLSBhbnkgZGVidWcgaW5mb3JtYXRpb24uXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvcihlcnJvcjogc3RyaW5nIHwgRXJyb3IsIGRhdGE/OiBhbnkpIHtcbiAgaWYgKHR5cGVvZiBkY2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGNsLmVycm9yKGVycm9yIGFzIGFueSwgZGF0YSlcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKCdFUlJPUjonLCBlcnJvciwgZGF0YSlcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG5ldyBwcmVmaXhlZCBpZFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gbmV3SWQodHlwZTogc3RyaW5nKSB7XG4gIGxhc3RHZW5lcmF0ZWRJZCsrXG4gIGlmICh0eXBlLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25ld0lkKHR5cGU6IHN0cmluZyk6IHR5cGUgY2Fubm90IGJlIGVtcHR5JylcbiAgcmV0dXJuIHR5cGUgKyBsYXN0R2VuZXJhdGVkSWQudG9TdHJpbmcoMzYpXG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dWlkKCkge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDBcbiAgICBjb25zdCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OFxuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KVxuICB9KVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGdpdmVuIHNpemUgZmlsbGVkIHdpdGggZWxlbWVudCBidWlsdCBmcm9tIHRoZSBnaXZlbiBjb25zdHJ1Y3RvciBhbmQgdGhlIHBhcmFtdGVyc1xuICogQHBhcmFtIHNpemUgLSB0aGUgbnVtYmVyIG9mIGVsZW1lbnQgdG8gY29uc3RydWN0IGFuZCBwdXQgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0gaXRlbUJ1aWxkZXIgLSBhIGNhbGxiYWNrIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2Ugb2YgaXRlbS4gQ2FsbGVkIG9uY2UgcGVyIGFycmF5IGVudHJ5LlxuICogQHJldHVybnMgYSBuZXcgYXJyYXkgZmlsbGVkIHdpdGggbmV3IG9iamVjdHNcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRBcnJheTxUPihzaXplOiBudW1iZXIsIGl0ZW1CdWlsZGVyOiAoKSA9PiBUKTogQXJyYXk8VD4ge1xuICBjb25zdCBhOiBUW10gPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgIGEucHVzaChpdGVtQnVpbGRlcigpKVxuICB9XG4gIHJldHVybiBhXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gb3BlbkV4dGVybmFsVVJMKHVybDogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgZGNsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRjbC5vcGVuRXh0ZXJuYWxVcmwodXJsKVxuICB9IGVsc2Uge1xuICAgIGVycm9yKCdFUlJPUjogb3BlbkV4dGVybmFsVVJMIGRjbCBpcyB1bmRlZmluZWQnKVxuICB9XG59XG5cbi8qKlxuICogUG9wdXAgTkZUIGluZm8gZGlhbG9nXG4gKiBAcGFyYW0gc2NyIC0gJ2V0aGVyZXVtOi8vY29udHJhY3RBZGRyZXNzL3Rva2VuSUQnXG4gKiBAcGFyYW0gY29tbWVudCAtIG9wdGlvbmFsLiBhZGQgYSBjb21tZW50LlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gb3Blbk5GVERpYWxvZyhzY3I6IHN0cmluZywgY29tbWVudDogc3RyaW5nIHwgbnVsbCA9IG51bGwpIHtcbiAgaWYgKHR5cGVvZiBkY2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgcmVnZXggPSAvZXRoZXJldW06XFwvXFwvKC4rKVxcLyguKykvXG4gICAgY29uc3QgbWF0Y2hlcyA9IHNjci5tYXRjaChyZWdleClcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGRjbC5vcGVuTkZURGlhbG9nKG1hdGNoZXNbMV0sIG1hdGNoZXNbMl0sIGNvbW1lbnQpXG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ0VSUk9SOiBvcGVuTkZURGlhbG9nIGRjbCBpcyB1bmRlZmluZWQnKVxuICB9XG59XG4iXX0=