"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveThirdPartyCollectionOnlyCollection = exports.resolveThirdPartyCollectionName = exports.resolveThirdPartyCollection = exports.resolveCollectionV2 = exports.resolveCollectionV1ByCollectionName = exports.resolveCollectionV1 = exports.resolveCollectionV2Asset = exports.resolveCollectionV1Asset = exports.resolveCollectionV1AssetByCollectionName = exports.resolveEntityV3 = exports.resolveOffchainAsset = exports.resolveEthereumAsset = exports.resolveLegacyDclUrl = exports.resolveLandAsset = exports.internalResolver = exports.resolvers = void 0;
const helpers_1 = require("./helpers");
const land_utils_1 = require("./land-utils");
/**
 * Ordered map of resolvers.
 * @public
 */
exports.resolvers = {
    // Resolver for static offchain assets (quests deployed to static servers, not content server)
    "decentraland:off-chain:{registry}:{name}": resolveOffchainAsset,
    // Resolver for deployed entities. Deployed entities are used to specify portable experience identifiers that may be deployed anywhere in the web.
    "decentraland:entity:{cid}": resolveEntityV3,
    // collections v1 asset (by contract)
    "decentraland:{protocol}:collections-v1:{contract(0x[a-fA-F0-9]+)}:{name}": resolveCollectionV1Asset,
    // collections v1 asset (by name)
    "decentraland:{protocol}:collections-v1:{collectionName}:{name}": resolveCollectionV1AssetByCollectionName,
    // collections v2 asset (hex)
    "decentraland:{protocol}:collections-v2:{contract(0x[a-fA-F0-9]+)}:{id(0x[a-fA-F0-9]+)}": resolveCollectionV2Asset,
    // collections v2 asset (id)
    "decentraland:{protocol}:collections-v2:{contract(0x[a-fA-F0-9]+)}:{id([0-9]+)}": resolveCollectionV2Asset,
    // collections v1 (by contract)
    "decentraland:{protocol}:collections-v1:{contract(0x[a-fA-F0-9]+)}": resolveCollectionV1,
    // collections v1 (by name)
    "decentraland:{protocol}:collections-v1:{collectionName}": resolveCollectionV1ByCollectionName,
    // collections v2
    "decentraland:{protocol}:collections-v2:{contract(0x[a-fA-F0-9]+)}": resolveCollectionV2,
    // resolve LAND by position
    "decentraland:{protocol}:LAND:{position}": resolveLandAsset,
    // resolve third party names
    "decentraland:{protocol}:collections-thirdparty:{thirdPartyName}": resolveThirdPartyCollectionName,
    // resolve third party collections
    "decentraland:{protocol}:collections-thirdparty:{thirdPartyName}:{collectionId}": resolveThirdPartyCollectionOnlyCollection,
    // resolve third party assets
    "decentraland:{protocol}:collections-thirdparty:{thirdPartyName}:{collectionId}:{itemId}": resolveThirdPartyCollection
};
exports.internalResolver = (0, helpers_1.createParser)(exports.resolvers);
async function resolveLandAsset(uri, groups) {
    if (!(0, helpers_1.isValidProtocol)(groups.protocol))
        return;
    const contract = await (0, helpers_1.getContract)(groups.protocol, "LandProxy");
    let { x, y } = land_utils_1.LandUtils.parseParcelPosition(groups.position);
    if (isNaN(x) || isNaN(y)) {
        const decoded = land_utils_1.LandUtils.decodeTokenId(groups.position);
        x = Number(decoded.x);
        y = Number(decoded.y);
    }
    if (isNaN(x) || isNaN(y))
        return;
    const tokenId = land_utils_1.LandUtils.encodeTokenId(x, y);
    if (contract) {
        const r = await resolveEthereumAsset(uri, {
            contract,
            protocol: groups.protocol.toLowerCase(),
            tokenId: "0x" + tokenId.toString(16),
        });
        if (r)
            return Object.assign(Object.assign({}, r), { x,
                y });
    }
}
exports.resolveLandAsset = resolveLandAsset;
async function resolveLegacyDclUrl(uri) {
    let host;
    let path;
    if (uri.pathname.startsWith('//')) {
        // Web URL object does not recognize dcl:// and therefore pathname has an extra /
        let res = uri.pathname.replace(/^\/\//, "").split("/");
        host = res[0];
        path = res.slice(1);
    }
    else {
        host = uri.host;
        path = uri.pathname.replace(/^\//, "").split("/");
    }
    if (uri.protocol == "dcl:" && path.length == 1) {
        if (host == "base-avatars") {
            return (0, exports.internalResolver)(`urn:decentraland:off-chain:base-avatars:${path[0]}`);
        }
        else {
            return (0, exports.internalResolver)(`urn:decentraland:ethereum:collections-v1:${host}:${path[0]}`);
        }
    }
}
exports.resolveLegacyDclUrl = resolveLegacyDclUrl;
async function resolveEthereumAsset(uri, groups) {
    if (!(0, helpers_1.isValidProtocol)(groups.protocol))
        return;
    const contract = await (0, helpers_1.getContract)(groups.protocol, groups.contract);
    if (contract)
        return {
            namespace: "decentraland",
            uri,
            blockchain: "ethereum",
            type: "blockchain-asset",
            network: groups.protocol == "ethereum" ? "mainnet" : groups.protocol.toLowerCase(),
            contractAddress: contract,
            id: groups.tokenId,
        };
}
exports.resolveEthereumAsset = resolveEthereumAsset;
async function resolveOffchainAsset(uri, groups) {
    return {
        namespace: "decentraland",
        uri,
        type: "off-chain",
        registry: groups.registry,
        id: groups.name,
    };
}
exports.resolveOffchainAsset = resolveOffchainAsset;
async function resolveEntityV3(uri, groups) {
    let baseUrl;
    if (uri.searchParams.has('baseUrl')) {
        baseUrl = uri.searchParams.get('baseUrl');
    }
    return {
        namespace: "decentraland",
        uri,
        type: "entity",
        cid: groups.cid,
        baseUrl
    };
}
exports.resolveEntityV3 = resolveEntityV3;
async function resolveCollectionV1AssetByCollectionName(uri, groups) {
    // this only works in mainnet
    if (groups.protocol != "ethereum")
        return;
    const collection = await (0, helpers_1.getCollection)(groups.collectionName);
    return {
        namespace: "decentraland",
        uri,
        blockchain: "ethereum",
        type: "blockchain-collection-v1-asset",
        network: 'mainnet',
        contractAddress: (collection && collection.contractAddress) || null,
        id: groups.name,
        collectionName: (collection && collection.collectionId) || groups.collectionName,
    };
}
exports.resolveCollectionV1AssetByCollectionName = resolveCollectionV1AssetByCollectionName;
async function resolveCollectionV1Asset(uri, groups) {
    if (!(0, helpers_1.isValidProtocol)(groups.protocol))
        return;
    const contract = await (0, helpers_1.getContract)(groups.protocol, groups.contract);
    if (contract) {
        const collection = await (0, helpers_1.getCollection)(contract);
        return {
            namespace: "decentraland",
            uri,
            blockchain: "ethereum",
            type: "blockchain-collection-v1-asset",
            network: groups.protocol == "ethereum" ? "mainnet" : groups.protocol.toLowerCase(),
            contractAddress: contract,
            id: groups.name,
            collectionName: collection ? collection.collectionId : null,
        };
    }
}
exports.resolveCollectionV1Asset = resolveCollectionV1Asset;
async function resolveCollectionV2Asset(uri, groups) {
    if (!(0, helpers_1.isValidProtocol)(groups.protocol))
        return;
    const contract = await (0, helpers_1.getContract)(groups.protocol, groups.contract);
    if (contract)
        return {
            namespace: "decentraland",
            uri,
            blockchain: "ethereum",
            type: "blockchain-collection-v2-asset",
            network: groups.protocol == "ethereum" ? "mainnet" : groups.protocol.toLowerCase(),
            contractAddress: contract,
            id: groups.id,
        };
}
exports.resolveCollectionV2Asset = resolveCollectionV2Asset;
async function resolveCollectionV1(uri, groups) {
    if (!(0, helpers_1.isValidProtocol)(groups.protocol))
        return;
    const contract = await (0, helpers_1.getContract)(groups.protocol, groups.contract);
    if (contract) {
        const collection = await (0, helpers_1.getCollection)(contract);
        return {
            namespace: "decentraland",
            uri,
            blockchain: "ethereum",
            type: "blockchain-collection-v1",
            network: groups.protocol == "ethereum" ? "mainnet" : groups.protocol.toLowerCase(),
            id: contract,
            collectionName: collection ? collection.collectionId : null
        };
    }
}
exports.resolveCollectionV1 = resolveCollectionV1;
async function resolveCollectionV1ByCollectionName(uri, groups) {
    // this only works in mainnet
    if (groups.protocol != "ethereum")
        return;
    const collection = await (0, helpers_1.getCollection)(groups.collectionName);
    if (collection) {
        return {
            namespace: "decentraland",
            uri,
            blockchain: "ethereum",
            type: "blockchain-collection-v1",
            network: 'mainnet',
            id: collection.contractAddress,
            collectionName: groups.collectionName,
        };
    }
}
exports.resolveCollectionV1ByCollectionName = resolveCollectionV1ByCollectionName;
async function resolveCollectionV2(uri, groups) {
    if (!(0, helpers_1.isValidProtocol)(groups.protocol))
        return;
    const contract = await (0, helpers_1.getContract)(groups.protocol, groups.contract);
    if (contract)
        return {
            namespace: "decentraland",
            uri,
            blockchain: "ethereum",
            type: "blockchain-collection-v2",
            network: groups.protocol == "ethereum" ? "mainnet" : groups.protocol.toLowerCase(),
            contractAddress: contract,
            id: contract,
        };
}
exports.resolveCollectionV2 = resolveCollectionV2;
async function resolveThirdPartyCollection(uri, groups) {
    if (!(0, helpers_1.isValidProtocol)(groups.protocol))
        return;
    const contract = await (0, helpers_1.getContract)(groups.protocol, "TPR");
    if (contract) {
        return {
            namespace: "decentraland",
            uri,
            blockchain: "ethereum",
            type: "blockchain-collection-third-party",
            network: groups.protocol == "ethereum" ? "mainnet" : groups.protocol.toLowerCase(),
            thirdPartyName: groups.thirdPartyName,
            collectionId: groups.collectionId,
            itemId: groups.itemId,
            contractAddress: contract
        };
    }
}
exports.resolveThirdPartyCollection = resolveThirdPartyCollection;
async function resolveThirdPartyCollectionName(uri, groups) {
    if (!(0, helpers_1.isValidProtocol)(groups.protocol))
        return;
    const contract = await (0, helpers_1.getContract)(groups.protocol, "TPR");
    if (contract) {
        return {
            namespace: "decentraland",
            uri,
            blockchain: "ethereum",
            type: "blockchain-collection-third-party-name",
            network: groups.protocol == "ethereum" ? "mainnet" : groups.protocol.toLowerCase(),
            thirdPartyName: groups.thirdPartyName,
            contractAddress: contract
        };
    }
}
exports.resolveThirdPartyCollectionName = resolveThirdPartyCollectionName;
async function resolveThirdPartyCollectionOnlyCollection(uri, groups) {
    if (!(0, helpers_1.isValidProtocol)(groups.protocol))
        return;
    const contract = await (0, helpers_1.getContract)(groups.protocol, "TPR");
    if (contract) {
        return {
            namespace: "decentraland",
            uri,
            blockchain: "ethereum",
            type: "blockchain-collection-third-party-collection",
            network: groups.protocol == "ethereum" ? "mainnet" : groups.protocol.toLowerCase(),
            thirdPartyName: groups.thirdPartyName,
            collectionId: groups.collectionId,
            contractAddress: contract
        };
    }
}
exports.resolveThirdPartyCollectionOnlyCollection = resolveThirdPartyCollectionOnlyCollection;
//# sourceMappingURL=resolvers.js.map