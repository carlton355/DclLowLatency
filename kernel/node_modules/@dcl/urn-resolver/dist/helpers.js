"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createParser = exports.isValidProtocol = exports.getContract = exports.getCollection = void 0;
const contracts_1 = __importDefault(require("./contracts"));
const collections_v1_1 = __importDefault(require("./collections-v1"));
/**
 * Map collection-name to contractAddress
 */
const collections = [];
const lowerCasedContracts = {};
const validProtocols = new Set(["ethereum", "kovan", "rinkeby", "goerli", "matic", "mumbai"]);
for (let network in contracts_1.default) {
    lowerCasedContracts[network] = Object.create(null);
    const c = lowerCasedContracts[network];
    if (network.toLowerCase() != "mainnet") {
        validProtocols.add(network.toLowerCase());
    }
    Object.keys(contracts_1.default[network]).forEach((key) => {
        c[key.toLowerCase()] = contracts_1.default[network][key];
    });
}
collections_v1_1.default.forEach((collection) => {
    collections.push({
        contractAddress: collection.id,
        collectionId: collection.name.replace(/^dcl:\/\//, ""),
    });
});
async function getCollection(addressOrName) {
    let sanitizedAddress = addressOrName.toLowerCase();
    for (let collection of collections) {
        if (collection.contractAddress == sanitizedAddress || collection.collectionId == addressOrName)
            return collection;
    }
    return null;
}
exports.getCollection = getCollection;
function mapContract(network, contractNameOrAddress) {
    if (network == "ethereum")
        return mapContract("mainnet", contractNameOrAddress);
    if (lowerCasedContracts[network]) {
        if (contractNameOrAddress in lowerCasedContracts[network]) {
            return lowerCasedContracts[network][contractNameOrAddress];
        }
    }
    else {
        console.log("network", network, Object.keys(lowerCasedContracts));
    }
    return null;
}
async function getContract(network, contractNameOrAddress) {
    if (contractNameOrAddress.startsWith("0x"))
        return contractNameOrAddress;
    return mapContract(network.toLowerCase(), contractNameOrAddress.toLowerCase());
}
exports.getContract = getContract;
function isValidProtocol(protocol) {
    return validProtocols.has(protocol.toLowerCase());
}
exports.isValidProtocol = isValidProtocol;
/**
 * @public
 */
function createParser(handlers) {
    return async (urn) => {
        const url = new URL(urn);
        if (url.protocol != "urn:")
            return null;
        for (let expression in handlers) {
            const expr = expression.replace(/(?:{([a-zA-Z_][a-zA-Z_0-9]*)(\([^}]+\))?})/g, function (substring, name, _matcher) {
                const matcher = _matcher || "[^:]+";
                return `(?<${name}>${matcher})`;
            });
            const regex = new RegExp("^" + expr + "$");
            const res = regex.exec(url.pathname);
            if (res) {
                const groups = Object.create(null);
                if (res.groups) {
                    for (let key in res.groups) {
                        groups[key] = decodeURIComponent(res.groups[key]);
                    }
                }
                const match = await handlers[expression](url, groups);
                if (match)
                    return match;
            }
        }
        return null;
    };
}
exports.createParser = createParser;
//# sourceMappingURL=helpers.js.map