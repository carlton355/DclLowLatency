import { PeerIncomingMessage } from './lighthouse-protocol/messages';
import EventEmitter from 'eventemitter3';
import { HandshakeData, ValidationMessagePayload } from './peerjs-server-connector/peerjsserverconnection';
import { ServerMessage } from './peerjs-server-connector/servermessage';
import { SocketBuilder } from './peerjs-server-connector/socket';
import { LogLevel, ValidationResult, WebRTCProvider } from './types';
declare type Logger = {
    log: (level: LogLevel, ...entries: any[]) => any;
};
declare type OptionalConfig = {
    logger: Logger;
    heartbeatInterval: number;
    connectionToken: string;
    heartbeatExtras: () => Record<string, any>;
    isReadyToEmitSignals: () => boolean;
    handshakePayloadExtras: () => Record<string, any>;
    handshakeValidator: (payload: HandshakeData, peerId: string) => ValidationResult;
    receivedOfferValidator: (payload: HandshakeData, peerId: string) => ValidationResult;
    serverMessageHandler: (message: PeerIncomingMessage) => void;
    rtcConnectionConfig: Record<string, any>;
    oldConnectionsTimeout: number;
    peerConnectTimeout: number;
};
declare type Config = {
    packetHandler: (data: Uint8Array, peerId: string) => void;
    peerId?: string;
    authHandler: (msg: string) => Promise<ValidationMessagePayload>;
    socketBuilder?: SocketBuilder;
    wrtc?: WebRTCProvider;
};
export declare type PeerWebRTCConfig = Partial<OptionalConfig> & Config;
export declare enum PeerWebRTCEvent {
    ConnectionRequestRejected = "ConnectionRequestRejected",
    PeerConnectionLost = "PeerConnectionLost",
    PeerConnectionEstablished = "PeerConnectionEstablished",
    ServerConnectionError = "ServerConnectionError"
}
export declare class PeerWebRTCHandler extends EventEmitter<PeerWebRTCEvent> {
    private connectedPeers;
    private peerConnectionPromises;
    private disposed;
    private peerJsConnection;
    config: OptionalConfig & Config;
    private _peerId;
    private _configuredId;
    private disconnectionCause;
    constructor(providedConfig: PeerWebRTCConfig);
    /**
     * This will try to obtain the peer's id.
     * If it is not assigned yet, then it will throw an error.
     */
    peerId(): string;
    maybePeerId(): string | undefined;
    setPeerServerUrl(peerServerUrl: string): void;
    cleanConnections(): void;
    disconnectFrom(peerId: string, removeListener?: boolean): void;
    private buildTopologyInfo;
    connectedCount(): number;
    fullyConnectedPeerIds(): string[];
    connectedPeerIds(): string[];
    isConnectedTo(peerId: string): boolean;
    private handleDisconnection;
    private handleConnection;
    private subscribeToConnection;
    private handlePeerError;
    private handlePeerPacket;
    private isReadyToEmitSignals;
    private handleSignal;
    private getOrCreatePeer;
    private createPeerConnection;
    private handleHandshakePayload;
    private handleOfferPayload;
    private checkForCrossOffers;
    hasConnectionsFor(peerId: string): boolean;
    private hasInitiatedConnectionFor;
    private handleCandidatePayload;
    private handleRejection;
    private signalMessage;
    handleMessage(message: ServerMessage): void;
    awaitConnectionEstablished(timeoutMs?: number): Promise<void>;
    connectTo(peerId: string): Promise<void>;
    beConnectedTo(peerId: string, timeout?: number): Promise<void>;
    checkConnectionsSanity(): void;
    sendPacketToPeer(peerId: string, data: Uint8Array): void;
    private log;
    dispose(): Promise<void>;
}
export {};
