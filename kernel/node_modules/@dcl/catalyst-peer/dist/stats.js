"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildCatalystPeerStatsData = exports.GlobalStats = exports.TypedStats = exports.Stats = void 0;
const util_1 = require("./utils/util");
function newPeriodicValue() {
    return { accumulatedInPeriod: 0 };
}
class Stats {
    constructor() {
        this.averagePacketSize = undefined;
        this.totalPackets = 0;
        this.totalBytes = 0;
        this.lastPeriodUpdate = 0;
        // Periodic stats. Each of these need to accumulate during a period to calculate their values
        this._bytesPerSecond = newPeriodicValue();
        this._packetsPerSecond = newPeriodicValue();
    }
    get bytesPerSecond() {
        return this._bytesPerSecond.currentValue;
    }
    get periodBytes() {
        return this._bytesPerSecond.lastAccumulatedValue;
    }
    get packetsPerSecond() {
        return this._packetsPerSecond.currentValue;
    }
    get periodPackets() {
        return this._packetsPerSecond.lastAccumulatedValue;
    }
    countPacket(packet, length, duplicate = false, expired = false) {
        this.totalPackets += 1;
        this._packetsPerSecond.accumulatedInPeriod += 1;
        this.totalBytes += length;
        this._bytesPerSecond.accumulatedInPeriod += length;
        this.averagePacketSize = this.totalBytes / this.totalPackets;
    }
    onPeriod(timestamp) {
        const elapsed = this.lastPeriodUpdate ? timestamp - this.lastPeriodUpdate : 0;
        const calculateAndReset = (value) => {
            if (elapsed) {
                value.currentValue = (value.accumulatedInPeriod * 1000) / elapsed;
            }
            value.lastAccumulatedValue = value.accumulatedInPeriod;
            value.accumulatedInPeriod = 0;
        };
        calculateAndReset(this._bytesPerSecond);
        calculateAndReset(this._packetsPerSecond);
        this.lastPeriodUpdate = timestamp;
    }
}
exports.Stats = Stats;
class TypedStats extends Stats {
    constructor() {
        super(...arguments);
        this.statsByType = {};
    }
    countPacket(packet, length) {
        var _a;
        super.countPacket(packet, length);
        if (packet.subtype) {
            const stats = (this.statsByType[packet.subtype] = (_a = this.statsByType[packet.subtype]) !== null && _a !== void 0 ? _a : new Stats());
            stats.countPacket(packet, length);
        }
    }
    onPeriod(timestamp) {
        super.onPeriod(timestamp);
        Object.values(this.statsByType).forEach((it) => it.onPeriod(timestamp));
    }
}
exports.TypedStats = TypedStats;
class GlobalStats {
    constructor(periodLength = 1000) {
        this.periodLength = periodLength;
        this.sent = new TypedStats();
        this.received = new TypedStats();
        this.relayed = new TypedStats();
        this.all = new TypedStats();
        this.tagged = {};
        this.onPeriodicStatsUpdated = (_) => { };
    }
    countPacket(packet, length, operation, tags = []) {
        this.all.countPacket(packet, length);
        this[operation].countPacket(packet, length);
        tags.forEach((tag) => {
            if (!this.tagged[tag]) {
                this.tagged[tag] = new TypedStats();
            }
            this.tagged[tag].countPacket(packet, length);
        });
    }
    onPeriod(timestamp) {
        this.all.onPeriod(timestamp);
        this.sent.onPeriod(timestamp);
        this.received.onPeriod(timestamp);
        this.relayed.onPeriod(timestamp);
        Object.values(this.tagged).forEach((it) => it.onPeriod(timestamp));
    }
    startPeriod() {
        const periodFunction = () => {
            this.onPeriod(performance.now());
            this.onPeriodicStatsUpdated(this);
            this.periodId = setTimeout(periodFunction, this.periodLength);
        };
        periodFunction();
    }
    dispose() {
        clearTimeout(this.periodId);
    }
    getStatsFor(statsKey) {
        if (this.hasOwnProperty(statsKey)) {
            return this[statsKey];
        }
        else {
            return this.tagged[statsKey];
        }
    }
}
exports.GlobalStats = GlobalStats;
/**
 * Helper function to build a data object to submit the stats for analytics
 */
function buildCatalystPeerStatsData(catalystPeer) {
    const stats = catalystPeer.stats;
    function buildStatsFor(statsKey) {
        var _a, _b, _c, _d, _e, _f, _g;
        const result = {};
        const typedStats = stats.getStatsFor(statsKey);
        result[statsKey] = (_a = typedStats === null || typedStats === void 0 ? void 0 : typedStats.periodPackets) !== null && _a !== void 0 ? _a : 0;
        result[`${statsKey}Total`] = (_b = typedStats === null || typedStats === void 0 ? void 0 : typedStats.totalPackets) !== null && _b !== void 0 ? _b : 0;
        result[`${statsKey}PerSecond`] = (_c = typedStats === null || typedStats === void 0 ? void 0 : typedStats.packetsPerSecond) !== null && _c !== void 0 ? _c : 0;
        result[`${statsKey}Bytes`] = (_d = typedStats === null || typedStats === void 0 ? void 0 : typedStats.periodBytes) !== null && _d !== void 0 ? _d : 0;
        result[`${statsKey}TotalBytes`] = (_e = typedStats === null || typedStats === void 0 ? void 0 : typedStats.totalBytes) !== null && _e !== void 0 ? _e : 0;
        result[`${statsKey}BytesPerSecond`] = (_f = typedStats === null || typedStats === void 0 ? void 0 : typedStats.bytesPerSecond) !== null && _f !== void 0 ? _f : 0;
        result[`${statsKey}AveragePacketSize`] = (_g = typedStats === null || typedStats === void 0 ? void 0 : typedStats.averagePacketSize) !== null && _g !== void 0 ? _g : 0;
        return result;
    }
    const statsToSubmit = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, buildStatsFor('sent')), buildStatsFor('received')), buildStatsFor('relayed')), buildStatsFor('all')), buildStatsFor('relevant')), buildStatsFor('duplicate')), buildStatsFor('expired')), { connectedPeers: catalystPeer.fullyConnectedPeerIds(), knownPeersCount: Object.keys(catalystPeer.knownPeers).length, position: catalystPeer.selfPosition() });
    const latencies = Object.values(catalystPeer.knownPeers)
        .map((kp) => kp.latency)
        .filter((it) => typeof it !== 'undefined');
    if (latencies.length > 0) {
        statsToSubmit['averageLatency'] = util_1.average(latencies);
    }
    return statsToSubmit;
}
exports.buildCatalystPeerStatsData = buildCatalystPeerStatsData;
//# sourceMappingURL=stats.js.map