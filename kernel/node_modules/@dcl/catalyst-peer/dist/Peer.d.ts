import { Position3D } from './utils/Positions';
import { PeerMessageType } from './messageTypes';
import { GlobalStats } from './stats';
import { KnownPeerData, LogLevel, MinPeerData, PacketCallback, PeerConfig, PingResult } from './types';
export declare class Peer {
    callback: PacketCallback;
    private wrtcHandler;
    private peerRelayData;
    knownPeers: Record<string, KnownPeerData>;
    private receivedPackets;
    readonly currentRooms: Set<string>;
    private httpClient;
    private currentIslandId;
    private preferedIslandId;
    private updatingNetwork;
    private currentMessageId;
    private instanceId;
    private expireTimeoutId;
    private updateNetworkTimeoutId;
    private pingTimeoutId?;
    stats: GlobalStats;
    private disposed;
    logLevel: keyof typeof LogLevel;
    private activePings;
    private retryingConnection;
    private config;
    constructor(lighthouseUrl: string, _peerId?: string, callback?: PacketCallback, _config?: PeerConfig);
    getCurrentIslandId(): string | undefined;
    get peerId(): string | undefined;
    /**
     * Sets the prefered island that'll be sent to the lighthouse to be used by archipelago.
     * There are three possible values:
     * * An Island id
     * * undefined: The parameter won't be sent to the server, and won't change the prefered island on server
     * * null: The prefered island will be cleard, if it was defined
     * */
    setPreferedIslandId(islandId: string | undefined | null): void;
    setLighthouseUrl(lighthouseUrl: string): void;
    peerIdOrFail(): string;
    private expireMessages;
    private expirePeers;
    private expirePeerRelayData;
    private expireKnownPeers;
    private disconnectFrom;
    private buildTopologyInfo;
    private buildPositionInfo;
    private markReceived;
    private packetKey;
    private getExpireTime;
    awaitConnectionEstablished(timeoutMs?: number): Promise<void>;
    private retryConnection;
    log(level: LogLevel, ...entries: any[]): void;
    set onIslandChange(onChange: ((islandId: string, peers: MinPeerData[]) => any) | undefined);
    get onIslandChange(): ((islandId: string, peers: MinPeerData[]) => any) | undefined;
    setIsland(islandId: string, peers: MinPeerData[]): void;
    private cleanStateAndConnections;
    joinRoom(roomId: string): Promise<any>;
    private setKnownPeers;
    private disconnectFromUnknownPeers;
    private updateKnownPeers;
    private addKnownPeerIfNotExists;
    private ensureAndUpdateKnownPeer;
    private removeKnownPeer;
    calculateConnectionCandidates(): string[];
    updateNetwork(): Promise<void>;
    private isValidConnectionCandidate;
    private isValidConnectionByDistance;
    private peerSortCriteria;
    private calculateNextNetworkOperation;
    private getWorstConnectedPeerByDistance;
    selfPosition(): Position3D | undefined;
    private distanceTo;
    connectedCount(): number;
    fullyConnectedPeerIds(): string[];
    connectTo(known: KnownPeerData): Promise<void>;
    leaveRoom(roomId: string): Promise<void>;
    beConnectedTo(peerId: string, timeout?: number): Promise<void>;
    setPeerPosition(peerId: string, position: Position3D): void;
    setPeerPositionIfExistingPositionIsOld(peerId: string, position: Position3D): void;
    isConnectedTo(peerId: string): boolean;
    private updateTimeStamp;
    private handlePeerPacket;
    private processPacket;
    private getPeerRelayData;
    private processSuspensionRequest;
    private requestRelaySuspension;
    private consolidateSuspensionRequest;
    private isRelayFromConnectionSuspended;
    private isRelayToConnectionSuspended;
    private countRelay;
    private getTagsForPacket;
    private processPong;
    private respondPing;
    private decodePayload;
    private checkExpired;
    private isDiscardedByOlderThanReceivedPackages;
    private isInRoom;
    private generateMessageId;
    private getEncodedPayload;
    sendMessage(roomId: string, payload: any, type: PeerMessageType): Promise<void>;
    private sendPacketWithData;
    private buildPacketWithData;
    ping(): Promise<PingResult[] | undefined>;
    private getPingTimeout;
    getTTL(index: number, type: PeerMessageType): number;
    getOptimistic(index: number, type: PeerMessageType): boolean;
    private sendPacket;
    private sendPacketToPeer;
    private lighthouseUrl;
    private handleServerMessage;
    private handleConnectionRequestRejected;
    private handlePeerConnectionLost;
    private handlePeerConnectionEstablished;
    private triggerUpdateNetwork;
    private validateHandshake;
    private validateReceivedOffer;
    dispose(): Promise<void>;
}
