"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PeerJSServerConnection = exports.createCandidateMessage = exports.createAnswerMessage = exports.createValidationMessage = exports.createOfferMessage = void 0;
/* eslint-disable @typescript-eslint/ban-types */
const eventemitter3_1 = require("eventemitter3");
const api_1 = require("./api");
const enums_1 = require("./enums");
const logger_1 = __importDefault(require("./logger"));
const socket_1 = require("./socket");
const util_1 = require("./util");
class PeerOptions {
}
function createOfferMessage(myId, peerData, handshakeData) {
    return createMessage(myId, peerData.id, enums_1.ServerMessageType.Offer, handshakeData);
}
exports.createOfferMessage = createOfferMessage;
function createValidationMessage(myId, payload) {
    return {
        type: enums_1.ServerMessageType.Validation,
        src: myId,
        payload
    };
}
exports.createValidationMessage = createValidationMessage;
function createAnswerMessage(myId, peerData, handshakeData) {
    return createMessage(myId, peerData.id, enums_1.ServerMessageType.Answer, handshakeData);
}
exports.createAnswerMessage = createAnswerMessage;
function createCandidateMessage(myId, peerData, candidateData, connectionId) {
    const payload = Object.assign(Object.assign({}, candidateData), { connectionId, sessionId: peerData.sessionId });
    const candidate = {
        type: enums_1.ServerMessageType.Candidate,
        src: myId,
        dst: peerData.id,
        payload
    };
    return candidate;
}
exports.createCandidateMessage = createCandidateMessage;
function createMessage(myId, dst, type, payload) {
    return {
        type,
        src: myId,
        dst,
        payload
    };
}
/**
 * Connector to the PeerJS server in order to publish and receive connection offers
 */
class PeerJSServerConnection extends eventemitter3_1.EventEmitter {
    constructor(handler, id, options) {
        super();
        // States.
        this._disconnected = false;
        this._open = false;
        /** Valid connection after the peer and the server complete the handshake (signature and validation of message) */
        this._valid = false;
        let userId;
        // Deal with overloading
        if (id && id.constructor === Object) {
            options = id;
        }
        else if (id) {
            userId = id.toString();
        }
        // Configurize options
        options = Object.assign({ debug: 0, host: util_1.util.CLOUD_HOST, port: util_1.util.CLOUD_PORT, path: '/', key: PeerJSServerConnection.DEFAULT_KEY, token: util_1.util.randomToken(), socketBuilder: (url) => new WebSocket(url) }, options);
        this._options = options;
        this._messageHandler = handler;
        // Set path correctly.
        if (this._options.path) {
            if (this._options.path[0] !== '/') {
                this._options.path = '/' + this._options.path;
            }
            if (this._options.path[this._options.path.length - 1] !== '/') {
                this._options.path += '/';
            }
        }
        // Set a custom log function if pre sent
        if (this._options.logFunction) {
            logger_1.default.setLogFunction(this._options.logFunction);
        }
        logger_1.default.logLevel = this._options.debug || 0;
        // Ensure alphanumeric id
        if (!!userId && !util_1.util.validateId(userId)) {
            this._delayedAbort(enums_1.PeerErrorType.InvalidID, `ID "${userId}" is invalid`);
            return;
        }
        this._api = new api_1.API(options);
        // Start the server connection
        this._initializeServerConnection();
        this._initialize(userId !== null && userId !== void 0 ? userId : null);
    }
    get id() {
        return this._id;
    }
    get messageHandler() {
        return this._messageHandler;
    }
    get options() {
        return this._options;
    }
    get open() {
        return this._open;
    }
    get connected() {
        return this._open && this._valid;
    }
    get socket() {
        return this._socket;
    }
    get disconnected() {
        return this._disconnected;
    }
    // Initialize the 'socket' (which is actually a mix of XHR streaming and
    // websockets.)
    _initializeServerConnection() {
        this._socket = new socket_1.Socket(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval, this._options.socketBuilder, this._options.heartbeatExtras);
        this.socket.on(enums_1.SocketEventType.Message, (data) => {
            this._handleMessage(data);
        });
        this.socket.on(enums_1.SocketEventType.Error, (error) => {
            this._abort(enums_1.PeerErrorType.SocketError, error);
        });
        this.socket.on(enums_1.SocketEventType.Disconnected, () => {
            // If we haven't explicitly disconnected, emit error and disconnect.
            if (!this.disconnected) {
                this.emitError(enums_1.PeerErrorType.Network, 'Lost connection to server.');
                this.disconnect().catch(() => {
                    // do nothing
                });
            }
        });
        this.socket.on(enums_1.SocketEventType.Close, () => {
            // If we haven't explicitly disconnected, emit error.
            if (!this.disconnected) {
                this._abort(enums_1.PeerErrorType.SocketClosed, 'Underlying socket is already closed.');
            }
        });
    }
    /** Initialize a connection with the server. */
    _initialize(id) {
        this._id = id;
        this.socket.start(this.id, this._options.token || 'asd');
    }
    /** Handles messages from the server. */
    _handleMessage(message) {
        logger_1.default.log('Received message', message);
        const type = message.type;
        const payload = message.payload;
        const peerId = message.src;
        switch (type) {
            case enums_1.ServerMessageType.AssignedId:
                this._id = message.payload.id;
                this.emit(enums_1.PeerEventType.AssignedId, this.id);
                break;
            case enums_1.ServerMessageType.Open: // The connection to the server is open.
                this.emit(enums_1.PeerEventType.Open, this.id);
                this._open = true;
                const { authHandler } = this._options;
                if (authHandler && payload) {
                    authHandler(payload)
                        .then((response) => this.sendValidation(response))
                        .catch((e) => {
                        logger_1.default.error('error while trying to handle auth message');
                        return '';
                    });
                }
                break;
            case enums_1.ServerMessageType.ValidationOk: // The connection to the server is accepted.
                this.emit(enums_1.PeerEventType.Valid, this.id);
                this._valid = true;
                break;
            case enums_1.ServerMessageType.ValidationNok: // The connection is aborted due to validation not correct
                this._abort(enums_1.PeerErrorType.ValidationError, `Result of validation challenge is incorrect`);
                break;
            case enums_1.ServerMessageType.Error: // Server error.
                this._abort(enums_1.PeerErrorType.ServerError, payload.msg);
                break;
            case enums_1.ServerMessageType.IdTaken: // The selected ID is taken.
                this._abort(enums_1.PeerErrorType.UnavailableID, `ID "${this.id}" is taken`);
                break;
            case enums_1.ServerMessageType.InvalidKey: // The given API key cannot be found.
                this._abort(enums_1.PeerErrorType.InvalidKey, `API KEY "${this._options.key}" is invalid`);
                break;
            case enums_1.ServerMessageType.Expire: // The offer sent to a peer has expired without response.
                this.emitError(enums_1.PeerErrorType.PeerUnavailable, 'Could not connect to peer ' + peerId);
                break;
            default:
                //All other messages are handled by the provided handler
                this.messageHandler.handleMessage(message);
                break;
        }
    }
    _delayedAbort(type, message) {
        setTimeout(() => {
            this._abort(type, message);
        }, 0);
    }
    /**
     * Emits an error message and destroys the Peer.
     * The Peer is not destroyed if it's in a disconnected state, in which case
     * it retains its disconnected state and its existing connections.
     */
    _abort(type, message) {
        logger_1.default.error('Aborting!');
        this.emitError(type, message);
        this.disconnect().catch(() => {
            // do nothing
        });
    }
    /** Emits a typed error message. */
    emitError(type, err) {
        logger_1.default.error('Error:', err);
        if (typeof err === 'string') {
            err = new Error(err);
        }
        err.type = type;
        this.emit(enums_1.PeerEventType.Error, err);
    }
    /**
     * Disconnects the Peer's connection to the PeerServer. Does not close any
     *  active connections.
     * Warning: The peer can no longer create or accept connections after being
     *  disconnected. It also cannot reconnect to the server.
     */
    disconnect() {
        return new Promise((resolve, reject) => {
            if (!this.disconnected) {
                this._disconnected = true;
                this._open = false;
                this._valid = false;
                if (this.socket) {
                    this.socket.close();
                }
                this.emit(enums_1.PeerEventType.Disconnected, this.id);
                this._lastServerId = this.id;
                this._id = null;
            }
            resolve();
        });
    }
    /** Attempts to reconnect with the same ID. */
    reconnect() {
        return new Promise((resolve, reject) => {
            if (this.disconnected) {
                logger_1.default.log('Attempting reconnection to server with ID ' + this._lastServerId);
                this._disconnected = false;
                this._initializeServerConnection();
                this._initialize(this._lastServerId);
                resolve();
            }
            else if (!this.disconnected && !this.open) {
                // Do nothing. We're still connecting the first time.
                logger_1.default.error("In a hurry? We're still trying to make the initial connection!");
                reject(new Error('Still making initial connection'));
            }
            else {
                reject(new Error('Peer ' + this.id + ' cannot reconnect because it is not disconnected from the server!'));
            }
        });
    }
    sendOffer(peerData, handshakeData) {
        this.socket.send(createOfferMessage(this.id, peerData, handshakeData));
    }
    sendAnswer(peerData, handshakeData) {
        this.socket.send(createAnswerMessage(this.id, peerData, handshakeData));
    }
    sendValidation(payload) {
        this.socket.send(createValidationMessage(this.id, payload));
    }
    sendCandidate(peerData, candidateData, connectionId) {
        this.socket.send(createCandidateMessage(this.id, peerData, candidateData, connectionId));
    }
    sendRejection(dst, sessionId, label, reason) {
        this.socket.send(createMessage(this.id, dst, enums_1.ServerMessageType.Reject, {
            sessionId,
            label,
            reason
        }));
    }
    /**
     * Get a list of available peer IDs. If you're running your own server, you'll
     * want to set allow_discovery: true in the PeerServer options. If you're using
     * the cloud server, email team@peerjs.com to get the functionality enabled for
     * your key.
     */
    listAllPeers(cb = (_) => { }) {
        this._api
            .listAllPeers()
            .then((peers) => cb(peers))
            .catch((error) => this._abort(enums_1.PeerErrorType.ServerError, error));
    }
}
exports.PeerJSServerConnection = PeerJSServerConnection;
PeerJSServerConnection.DEFAULT_KEY = 'peerjs';
//# sourceMappingURL=peerjsserverconnection.js.map