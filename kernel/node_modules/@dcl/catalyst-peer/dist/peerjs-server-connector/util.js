"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pickBy = exports.pickRandom = exports.noReject = exports.shuffle = exports.delay = exports.connectionIdFor = exports.util = void 0;
const util_1 = require("../utils/util");
// const DEFAULT_CONFIG = {
//   iceServers: [
//     { urls: "stun:stun.l.google.com:19302" },
//     {
//       urls: "turn:0.peerjs.com:3478",
//       username: "peerjs",
//       credential: "peerjsp"
//     }
//   ],
//   sdpSemantics: "unified-plan"
// };
exports.util = new (class {
    constructor() {
        this.CLOUD_HOST = '0.peerjs.com';
        this.CLOUD_PORT = 443;
    }
    noop() { }
    // Ensure supported ids
    validateId(id) {
        // Allow empty ids
        return !id || Array.from(id).every((it) => util_1.DEFAULT_ID_ALPHABET.includes(it));
    }
    randomToken() {
        return Math.random().toString(36).substr(2);
    }
    generateToken(n) {
        const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let token = '';
        for (let i = 0; i < n; i++) {
            token += chars[Math.floor(Math.random() * chars.length)];
        }
        return token;
    }
})();
function connectionIdFor(myId, peerId, sessionId) {
    return `${myId < peerId ? myId : peerId}_${myId < peerId ? peerId : myId}_${sessionId}`;
}
exports.connectionIdFor = connectionIdFor;
function delay(time) {
    return new Promise((resolve) => setTimeout(resolve, time));
}
exports.delay = delay;
function shuffle(array) {
    return array.sort(() => 0.5 - Math.random());
}
exports.shuffle = shuffle;
function noReject(promise) {
    return promise.then((value) => ['fulfilled', value], (error) => ['rejected', error]);
}
exports.noReject = noReject;
/**
 * Picks count random elements from the array and returns them and the remaining elements. If the array
 * has less or equal elements than the amount required, then it returns a copy of the array.
 */
function pickRandom(array, count) {
    return pickBy(array, count, () => 0.5 - Math.random());
}
exports.pickRandom = pickRandom;
/**
 * Picks the top `count` elements according to `criteria` from the array and returns them and the remaining elements. If the array
 * has less or equal elements than the amount required, then it returns a copy of the array sorted by `criteria`.
 */
function pickBy(array, count, criteria) {
    const sorted = array.sort(criteria);
    const selected = sorted.splice(0, count);
    return [selected, sorted];
}
exports.pickBy = pickBy;
//# sourceMappingURL=util.js.map