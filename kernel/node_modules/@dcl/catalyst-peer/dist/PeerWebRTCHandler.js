"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PeerWebRTCHandler = exports.PeerWebRTCEvent = void 0;
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const fp_future_1 = require("fp-future");
const simple_peer_1 = __importDefault(require("simple-peer"));
const constants_1 = require("./constants");
const enums_1 = require("./peerjs-server-connector/enums");
const peerjsserverconnection_1 = require("./peerjs-server-connector/peerjsserverconnection");
const util_1 = require("./peerjs-server-connector/util");
const TimeKeeper_1 = require("./TimeKeeper");
const types_1 = require("./types");
var PeerWebRTCEvent;
(function (PeerWebRTCEvent) {
    PeerWebRTCEvent["ConnectionRequestRejected"] = "ConnectionRequestRejected";
    PeerWebRTCEvent["PeerConnectionLost"] = "PeerConnectionLost";
    PeerWebRTCEvent["PeerConnectionEstablished"] = "PeerConnectionEstablished";
    PeerWebRTCEvent["ServerConnectionError"] = "ServerConnectionError";
})(PeerWebRTCEvent = exports.PeerWebRTCEvent || (exports.PeerWebRTCEvent = {}));
class PeerWebRTCHandler extends eventemitter3_1.default {
    constructor(providedConfig) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        super();
        this.connectedPeers = {};
        this.peerConnectionPromises = {};
        this.disposed = false;
        this._configuredId = providedConfig.peerId;
        this._peerId = this._configuredId;
        this.config = {
            wrtc: providedConfig.wrtc,
            logger: (_a = providedConfig.logger) !== null && _a !== void 0 ? _a : console,
            heartbeatInterval: (_b = providedConfig.heartbeatInterval) !== null && _b !== void 0 ? _b : constants_1.PEER_CONSTANTS.DEFAULT_HEARTBEAT_INTERVAL,
            connectionToken: (_c = providedConfig.connectionToken) !== null && _c !== void 0 ? _c : util_1.util.randomToken(),
            heartbeatExtras: (_d = providedConfig.heartbeatExtras) !== null && _d !== void 0 ? _d : (() => ({})),
            isReadyToEmitSignals: (_e = providedConfig.isReadyToEmitSignals) !== null && _e !== void 0 ? _e : (() => true),
            handshakePayloadExtras: (_f = providedConfig.handshakePayloadExtras) !== null && _f !== void 0 ? _f : (() => ({})),
            rtcConnectionConfig: (_g = providedConfig.rtcConnectionConfig) !== null && _g !== void 0 ? _g : {},
            authHandler: providedConfig.authHandler,
            serverMessageHandler: (_h = providedConfig.serverMessageHandler) !== null && _h !== void 0 ? _h : (() => { }),
            packetHandler: providedConfig.packetHandler,
            socketBuilder: providedConfig.socketBuilder,
            peerConnectTimeout: (_j = providedConfig.peerConnectTimeout) !== null && _j !== void 0 ? _j : constants_1.PEER_CONSTANTS.DEFAULT_PEER_CONNECT_TIMEOUT,
            oldConnectionsTimeout: (_k = providedConfig.oldConnectionsTimeout) !== null && _k !== void 0 ? _k : ((_l = providedConfig.peerConnectTimeout) !== null && _l !== void 0 ? _l : constants_1.PEER_CONSTANTS.DEFAULT_PEER_CONNECT_TIMEOUT) * 10,
            handshakeValidator: (_m = providedConfig.handshakeValidator) !== null && _m !== void 0 ? _m : (() => ({
                ok: true
            })),
            receivedOfferValidator: (_o = providedConfig.receivedOfferValidator) !== null && _o !== void 0 ? _o : (() => ({
                ok: true
            }))
        };
    }
    /**
     * This will try to obtain the peer's id.
     * If it is not assigned yet, then it will throw an error.
     */
    peerId() {
        if (this._peerId) {
            return this._peerId;
        }
        else {
            throw new Error("This peer doesn't have an id yet");
        }
    }
    maybePeerId() {
        return this._peerId;
    }
    setPeerServerUrl(peerServerUrl) {
        var _a, _b;
        (_a = this.peerJsConnection) === null || _a === void 0 ? void 0 : _a.removeAllListeners();
        (_b = this.peerJsConnection) === null || _b === void 0 ? void 0 : _b.disconnect().catch((e) => this.log(types_1.LogLevel.DEBUG, 'Error while disconnecting ', e));
        const url = new URL(peerServerUrl);
        const secure = url.protocol === 'https:';
        this.peerJsConnection = new peerjsserverconnection_1.PeerJSServerConnection(this, this._configuredId, Object.assign({ host: url.hostname, port: url.port ? parseInt(url.port) : secure ? 443 : 80, path: url.pathname, secure, pingInterval: this.config.heartbeatInterval, token: this.config.connectionToken, authHandler: this.config.authHandler, heartbeatExtras: () => (Object.assign(Object.assign({}, this.buildTopologyInfo()), this.config.heartbeatExtras())) }, (this.config.socketBuilder ? { socketBuilder: this.config.socketBuilder } : {})));
        this.peerJsConnection.on(enums_1.PeerEventType.AssignedId, (id) => (this._peerId = id));
        this.peerJsConnection.on(enums_1.PeerEventType.Error, (err) => this.emit(PeerWebRTCEvent.ServerConnectionError, err));
    }
    cleanConnections() {
        Object.keys(this.connectedPeers).forEach((it) => this.disconnectFrom(it));
    }
    disconnectFrom(peerId, removeListener = true) {
        if (this.connectedPeers[peerId]) {
            this.log(types_1.LogLevel.INFO, 'Disconnecting from ' + peerId);
            //We remove close listeners since we are going to destroy the connection anyway. No need to handle the events.
            if (removeListener)
                this.connectedPeers[peerId].connection.removeAllListeners('close');
            this.connectedPeers[peerId].connection.destroy();
            delete this.connectedPeers[peerId];
        }
        else {
            this.log(types_1.LogLevel.INFO, '[PEER] Already not connected to peer ' + peerId);
        }
    }
    buildTopologyInfo() {
        return { connectedPeerIds: this.fullyConnectedPeerIds() };
    }
    connectedCount() {
        return this.fullyConnectedPeerIds().length;
    }
    fullyConnectedPeerIds() {
        return Object.keys(this.connectedPeers).filter((it) => this.isConnectedTo(it));
    }
    connectedPeerIds() {
        return Object.keys(this.connectedPeers);
    }
    isConnectedTo(peerId) {
        return (
        //The `connected` property is not typed but it seems to be public
        this.connectedPeers[peerId] && this.connectedPeers[peerId].connection.connected);
    }
    handleDisconnection(peerData) {
        this.log(types_1.LogLevel.INFO, 'DISCONNECTED from ' + peerData.id + ' through ' + util_1.connectionIdFor(this.peerId(), peerData.id, peerData.sessionId));
        // TODO - maybe add a callback for the client to know that a peer has been disconnected, also might need to handle connection errors - moliva - 16/12/2019
        if (this.connectedPeers[peerData.id]) {
            delete this.connectedPeers[peerData.id];
        }
        if (this.peerConnectionPromises[peerData.id]) {
            this.peerConnectionPromises[peerData.id].forEach((it) => it.reject());
            delete this.peerConnectionPromises[peerData.id];
        }
        this.emit(PeerWebRTCEvent.PeerConnectionLost, peerData);
    }
    handleConnection(peerData) {
        var _a;
        this.log(types_1.LogLevel.INFO, 'CONNECTED to ' + peerData.id + ' through ' + util_1.connectionIdFor(this.peerId(), peerData.id, peerData.sessionId));
        (_a = this.peerConnectionPromises[peerData.id]) === null || _a === void 0 ? void 0 : _a.forEach(($) => $.resolve());
        delete this.peerConnectionPromises[peerData.id];
        this.emit(PeerWebRTCEvent.PeerConnectionEstablished, peerData);
    }
    subscribeToConnection(peerData, connection) {
        connection.on('signal', this.handleSignal(peerData));
        connection.on('close', () => this.handleDisconnection(peerData));
        connection.on('connect', () => this.handleConnection(peerData));
        connection.on('error', (err) => this.handlePeerError(peerData, err, connection));
        connection.on('data', (data) => this.handlePeerPacket(data, peerData.id));
    }
    handlePeerError(peerData, err, connection) {
        this.log(types_1.LogLevel.ERROR, 'error in peer connection ' + util_1.connectionIdFor(this.peerId(), peerData.id, peerData.sessionId), err);
        connection.removeAllListeners();
        connection.destroy();
        this.handleDisconnection(peerData);
    }
    handlePeerPacket(data, peerId) {
        if (this.disposed)
            return;
        this.config.packetHandler(data, peerId);
    }
    isReadyToEmitSignals() {
        return this.config.isReadyToEmitSignals();
    }
    handleSignal(peerData) {
        const connectionId = util_1.connectionIdFor(this.peerId(), peerData.id, peerData.sessionId);
        return (data) => {
            var _a;
            if (this.disposed)
                return;
            // We ignore signals for connections that we are not referencing (could be old connections)
            if (!this.connectedPeers[peerData.id] || this.connectedPeers[peerData.id].sessionId !== peerData.sessionId)
                return;
            this.log(types_1.LogLevel.DEBUG, `Signal in peer connection ${connectionId}: ${(_a = data.type) !== null && _a !== void 0 ? _a : 'candidate'}`);
            if (this.isReadyToEmitSignals()) {
                if (data.type === constants_1.PeerSignals.offer) {
                    this.peerJsConnection.sendOffer(peerData, Object.assign({ sdp: data, sessionId: peerData.sessionId, connectionId }, this.config.handshakePayloadExtras()));
                }
                else if (data.type === constants_1.PeerSignals.answer) {
                    this.peerJsConnection.sendAnswer(peerData, Object.assign({ sdp: data, sessionId: peerData.sessionId, connectionId }, this.config.handshakePayloadExtras()));
                }
                else if (data.type === constants_1.PeerSignals.candidate) {
                    this.peerJsConnection.sendCandidate(peerData, data, connectionId);
                }
            }
            else {
                this.log(types_1.LogLevel.WARN, 'Ignoring connection signal since the peer is not ready to emit signals yet', peerData, data);
            }
        };
    }
    getOrCreatePeer(peerId, initiator = false, room, sessionId) {
        let peer = this.connectedPeers[peerId];
        if (!peer) {
            sessionId = sessionId !== null && sessionId !== void 0 ? sessionId : util_1.util.generateToken(16);
            peer = this.createPeerConnection(peerId, sessionId, initiator);
        }
        else if (sessionId) {
            if (peer.sessionId !== sessionId) {
                this.log(types_1.LogLevel.INFO, `Received new connection from peer with new session id. Peer: ${peer.id}. Old: ${peer.sessionId}. New: ${sessionId}. Initiator: ${initiator}`);
                peer.connection.removeAllListeners();
                peer.connection.destroy();
                peer = this.createPeerConnection(peerId, sessionId, initiator);
            }
        }
        return peer;
    }
    createPeerConnection(peerId, sessionId, initiator) {
        const peer = (this.connectedPeers[peerId] = {
            id: peerId,
            sessionId,
            initiator,
            createTimestamp: TimeKeeper_1.TimeKeeper.now(),
            connection: new simple_peer_1.default({
                initiator,
                config: this.config.rtcConnectionConfig,
                channelName: util_1.connectionIdFor(this.peerId(), peerId, sessionId),
                wrtc: this.config.wrtc,
                objectMode: true
            })
        });
        this.subscribeToConnection(peer, peer.connection);
        return peer;
    }
    handleHandshakePayload(payload, peerId) {
        var _a;
        const result = this.config.handshakeValidator(payload, peerId);
        if (!result.ok) {
            this.peerJsConnection.sendRejection(peerId, payload.sessionId, payload.label, (_a = result.message) !== null && _a !== void 0 ? _a : '');
            return;
        }
        const peer = this.getOrCreatePeer(peerId, false, payload.label, payload.sessionId);
        this.signalMessage(peer, payload.sdp);
    }
    handleOfferPayload(payload, peerId) {
        var _a;
        if (this.checkForCrossOffers(peerId)) {
            return;
        }
        const result = this.config.receivedOfferValidator(payload, peerId);
        if (!result.ok) {
            this.peerJsConnection.sendRejection(peerId, payload.sessionId, payload.label, (_a = result.message) !== null && _a !== void 0 ? _a : '');
            return;
        }
        this.handleHandshakePayload(payload, peerId);
    }
    checkForCrossOffers(peerId, sessionId) {
        const isCrossOfferToBeDiscarded = this.hasInitiatedConnectionFor(peerId) &&
            (!sessionId || this.connectedPeers[peerId].sessionId !== sessionId) &&
            this.peerId() < peerId;
        if (isCrossOfferToBeDiscarded) {
            this.log(types_1.LogLevel.WARN, 'Received offer/candidate for already existing peer but it was discarded: ' + peerId);
        }
        return isCrossOfferToBeDiscarded;
    }
    hasConnectionsFor(peerId) {
        return !!this.connectedPeers[peerId];
    }
    hasInitiatedConnectionFor(peerId) {
        return this.hasConnectionsFor(peerId) && this.connectedPeers[peerId].initiator;
    }
    handleCandidatePayload(peerId, payload) {
        if (this.checkForCrossOffers(peerId, payload.sessionId)) {
            return;
        }
        // If we receive a candidate for a connection that we don't have, we ignore it
        if (!this.hasConnectionsFor(peerId)) {
            this.log(types_1.LogLevel.INFO, `Received candidate for unknown peer connection: ${peerId}. Ignoring.`);
            return;
        }
        const peer = this.getOrCreatePeer(peerId, false, payload.label, payload.sessionId);
        this.signalMessage(peer, {
            type: 'candidate',
            candidate: payload.candidate
        });
    }
    handleRejection(peerId, reason) {
        var _a;
        const peer = this.connectedPeers[peerId];
        (_a = peer === null || peer === void 0 ? void 0 : peer.connection) === null || _a === void 0 ? void 0 : _a.destroy();
        delete this.connectedPeers[peerId];
        this.emit(PeerWebRTCEvent.ConnectionRequestRejected, peerId, reason);
    }
    signalMessage(peer, signal) {
        try {
            peer.connection.signal(signal);
        }
        catch (e) {
            // If this fails, then most likely the connection hasn't been initialized properly (RTCPeerConnection couldn't be created)
            // We handle it with the same error handler as any other error
            this.handlePeerError(peer, e, peer.connection);
        }
    }
    handleMessage(message) {
        if (this.disposed)
            return;
        const { type, payload, src: peerId, dst } = message;
        if (dst === this._peerId) {
            this.log(types_1.LogLevel.DEBUG, `Received message from ${peerId}: ${type}`, message);
            switch (type) {
                case enums_1.ServerMessageType.Offer: {
                    this.handleOfferPayload(payload, peerId);
                    break;
                }
                case enums_1.ServerMessageType.Answer: {
                    this.handleHandshakePayload(payload, peerId);
                    break;
                }
                case enums_1.ServerMessageType.Candidate: {
                    this.handleCandidatePayload(peerId, payload);
                    break;
                }
                case enums_1.ServerMessageType.Reject: {
                    this.handleRejection(peerId, payload.reason);
                    break;
                }
                default: {
                    this.config.serverMessageHandler(message);
                }
            }
        }
    }
    awaitConnectionEstablished(timeoutMs = 10000) {
        var _a;
        // check connection state
        if (this.peerJsConnection.connected) {
            return Promise.resolve();
        }
        else if (this.peerJsConnection.disconnected) {
            return Promise.reject((_a = this.disconnectionCause) !== null && _a !== void 0 ? _a : new Error('Peer already disconnected!'));
        }
        // otherwise wait for connection to be established/rejected
        const result = fp_future_1.future();
        setTimeout(() => {
            result.isPending &&
                result.reject(new Error(`[${this.maybePeerId()}] Awaiting connection to server timed out after ${timeoutMs}ms`));
        }, timeoutMs);
        this.peerJsConnection.on(enums_1.PeerEventType.Error, async (err) => {
            if (result.isPending) {
                return result.reject(err);
            }
        });
        this.peerJsConnection.on(enums_1.PeerEventType.Valid, () => result.isPending && result.resolve());
        return result;
    }
    async connectTo(peerId) {
        const peer = this.createPeerConnection(peerId, util_1.util.generateToken(16), true);
        return this.beConnectedTo(peer.id, this.config.peerConnectTimeout).catch((e) => {
            // If we timeout, we want to abort the connection
            this.disconnectFrom(peerId, false);
            throw e;
        });
    }
    beConnectedTo(peerId, timeout = 10000) {
        return new Promise((resolve, reject) => {
            const promisePair = { resolve, reject };
            if (this.isConnectedTo(peerId)) {
                resolve();
            }
            else {
                this.peerConnectionPromises[peerId] = [...(this.peerConnectionPromises[peerId] || []), promisePair];
            }
            setTimeout(() => {
                if (!this.isConnectedTo(peerId) && this.peerConnectionPromises[peerId]) {
                    reject(new Error(`[${this.maybePeerId()}] Awaiting connection to peer ${peerId} timed out after ${timeout}ms`));
                    this.peerConnectionPromises[peerId] = this.peerConnectionPromises[peerId].splice(this.peerConnectionPromises[peerId].indexOf(promisePair), 1);
                }
                else {
                    resolve();
                }
            }, timeout);
        });
    }
    checkConnectionsSanity() {
        //Since there may be flows that leave connections that are actually lost, we check if relatively
        //old connections are not connected and discard them.
        Object.keys(this.connectedPeers).forEach((it) => {
            if (!this.isConnectedTo(it) &&
                TimeKeeper_1.TimeKeeper.now() - this.connectedPeers[it].createTimestamp > this.config.oldConnectionsTimeout) {
                this.log(types_1.LogLevel.WARN, `The connection to ${it} is not in a sane state. Discarding it.`);
                this.disconnectFrom(it, false);
            }
        });
    }
    sendPacketToPeer(peerId, data) {
        var _a;
        const conn = (_a = this.connectedPeers[peerId]) === null || _a === void 0 ? void 0 : _a.connection;
        if (conn) {
            conn.send(data);
        }
    }
    log(level, ...entries) {
        this.config.logger.log(level, ...entries);
    }
    async dispose() {
        this.disposed = true;
        this.cleanConnections();
        return new Promise((resolve, reject) => {
            if (this.peerJsConnection && !this.peerJsConnection.disconnected) {
                this.peerJsConnection.once(enums_1.PeerEventType.Disconnected, resolve);
                this.peerJsConnection
                    .disconnect()
                    .then(() => resolve())
                    .catch((e) => reject(e));
            }
            else {
                resolve();
            }
        });
    }
}
exports.PeerWebRTCHandler = PeerWebRTCHandler;
//# sourceMappingURL=PeerWebRTCHandler.js.map