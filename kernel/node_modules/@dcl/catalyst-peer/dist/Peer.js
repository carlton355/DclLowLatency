"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Peer = void 0;
const messages_1 = require("./lighthouse-protocol/messages");
const fp_future_1 = require("fp-future");
const minimal_1 = require("protobufjs/minimal");
const Positions_1 = require("./utils/Positions");
const util_1 = require("./utils/util");
const constants_1 = require("./constants");
const messageTypes_1 = require("./messageTypes");
const PeerHttpClient_1 = require("./PeerHttpClient");
const enums_1 = require("./peerjs-server-connector/enums");
const util_2 = require("./peerjs-server-connector/util");
const PeerWebRTCHandler_1 = require("./PeerWebRTCHandler");
const peer_protobuf_1 = require("./proto/peer_protobuf");
const stats_1 = require("./stats");
const TimeKeeper_1 = require("./TimeKeeper");
const types_1 = require("./types");
const PROTOCOL_VERSION = 5;
// Try not to use this. It is domain specific and should be phased out eventually
function toParcel(position) {
    if (position instanceof Array && position.length === 3) {
        return [Math.floor(position[0] / 16), Math.floor(position[2] / 16)];
    }
}
class Peer {
    constructor(lighthouseUrl, _peerId, callback = () => { }, _config = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.callback = callback;
        this.peerRelayData = {};
        this.knownPeers = {};
        this.receivedPackets = {};
        this.currentRooms = new Set();
        this.updatingNetwork = false;
        this.currentMessageId = 0;
        this.disposed = false;
        this.logLevel = 'INFO';
        this.activePings = {};
        this.retryingConnection = false;
        this.config = Object.assign({ authHandler: (msg) => Promise.resolve(msg), eventsHandler: {} }, _config);
        if (this.config.logLevel) {
            this.logLevel = this.config.logLevel;
        }
        this.config.targetConnections = (_a = this.config.targetConnections) !== null && _a !== void 0 ? _a : constants_1.PEER_CONSTANTS.DEFAULT_TARGET_CONNECTIONS;
        this.config.maxConnections = (_b = this.config.maxConnections) !== null && _b !== void 0 ? _b : constants_1.PEER_CONSTANTS.DEFAULT_MAX_CONNECTIONS;
        this.config.messageExpirationTime =
            (_c = this.config.messageExpirationTime) !== null && _c !== void 0 ? _c : constants_1.PEER_CONSTANTS.DEFAULT_MESSAGE_EXPIRATION_TIME;
        this.config.reconnectionAttempts = (_d = this.config.reconnectionAttempts) !== null && _d !== void 0 ? _d : constants_1.PEER_CONSTANTS.DEFAULT_RECONNECTIONS_ATTEMPTS;
        this.config.backoffMs = (_e = this.config.backoffMs) !== null && _e !== void 0 ? _e : constants_1.PEER_CONSTANTS.DEFAULT_RECONNECTION_BACKOFF_MS;
        if (this.config.positionConfig) {
            this.config.positionConfig.distance = (_f = this.config.positionConfig.distance) !== null && _f !== void 0 ? _f : Positions_1.discretizedPositionDistanceXZ();
            this.config.positionConfig.nearbyPeersDistance =
                (_g = this.config.positionConfig.nearbyPeersDistance) !== null && _g !== void 0 ? _g : Positions_1.DISCRETIZE_POSITION_INTERVALS[Positions_1.DISCRETIZE_POSITION_INTERVALS.length - 1];
        }
        this.instanceId = util_1.randomUint32();
        this.wrtcHandler = new PeerWebRTCHandler_1.PeerWebRTCHandler({
            peerId: _peerId,
            logger: this,
            wrtc: this.config.wrtc,
            socketBuilder: this.config.socketBuilder,
            heartbeatExtras: () => (Object.assign(Object.assign({}, this.buildTopologyInfo()), this.buildPositionInfo())),
            authHandler: this.config.authHandler,
            isReadyToEmitSignals: () => !!this.currentIslandId,
            handshakePayloadExtras: () => ({
                protocolVersion: PROTOCOL_VERSION,
                lighthouseUrl: this.lighthouseUrl(),
                islandId: this.currentIslandId,
                position: this.selfPosition()
            }),
            connectionToken: this.config.token,
            rtcConnectionConfig: this.config.connectionConfig,
            serverMessageHandler: this.handleServerMessage.bind(this),
            packetHandler: this.handlePeerPacket.bind(this),
            handshakeValidator: this.validateHandshake.bind(this),
            oldConnectionsTimeout: this.config.oldConnectionsTimeout,
            peerConnectTimeout: this.config.peerConnectTimeout,
            receivedOfferValidator: this.validateReceivedOffer.bind(this),
            heartbeatInterval: this.config.heartbeatInterval
        });
        this.wrtcHandler.on(PeerWebRTCHandler_1.PeerWebRTCEvent.ConnectionRequestRejected, this.handleConnectionRequestRejected.bind(this));
        this.wrtcHandler.on(PeerWebRTCHandler_1.PeerWebRTCEvent.PeerConnectionLost, this.handlePeerConnectionLost.bind(this));
        this.wrtcHandler.on(PeerWebRTCHandler_1.PeerWebRTCEvent.PeerConnectionEstablished, this.handlePeerConnectionEstablished.bind(this));
        this.wrtcHandler.on(PeerWebRTCHandler_1.PeerWebRTCEvent.ServerConnectionError, async (err) => {
            var _a, _b;
            if (err.type === enums_1.PeerErrorType.UnavailableID) {
                (_b = (_a = this.config.eventsHandler).statusHandler) === null || _b === void 0 ? void 0 : _b.call(_a, 'id-taken');
            }
            else {
                if (!this.retryingConnection)
                    await this.retryConnection();
            }
        });
        this.setLighthouseUrl(lighthouseUrl);
        const scheduleExpiration = () => setTimeout(() => {
            try {
                this.expireMessages();
                this.expirePeers();
            }
            catch (e) {
                this.log(types_1.LogLevel.ERROR, "Couldn't expire messages", e);
            }
            finally {
                this.expireTimeoutId = scheduleExpiration();
            }
        }, constants_1.PEER_CONSTANTS.EXPIRATION_LOOP_INTERVAL);
        const scheduleUpdateNetwork = () => setTimeout(() => {
            this.triggerUpdateNetwork('scheduled network update');
            this.updateNetworkTimeoutId = scheduleUpdateNetwork();
        }, constants_1.PEER_CONSTANTS.UPDATE_NETWORK_INTERVAL);
        this.expireTimeoutId = scheduleExpiration();
        this.updateNetworkTimeoutId = scheduleUpdateNetwork();
        if (this.config.pingInterval) {
            const schedulePing = () => setTimeout(async () => {
                try {
                    await this.ping();
                }
                finally {
                    this.pingTimeoutId = schedulePing();
                }
            }, this.config.pingInterval);
            this.pingTimeoutId = schedulePing();
        }
        this.stats = new stats_1.GlobalStats((_h = this.config.statsUpdateInterval) !== null && _h !== void 0 ? _h : constants_1.PEER_CONSTANTS.DEFAULT_STATS_UPDATE_INTERVAL);
        this.stats.startPeriod();
    }
    getCurrentIslandId() {
        return this.currentIslandId;
    }
    get peerId() {
        return this.wrtcHandler.maybePeerId();
    }
    /**
     * Sets the prefered island that'll be sent to the lighthouse to be used by archipelago.
     * There are three possible values:
     * * An Island id
     * * undefined: The parameter won't be sent to the server, and won't change the prefered island on server
     * * null: The prefered island will be cleard, if it was defined
     * */
    setPreferedIslandId(islandId) {
        this.preferedIslandId = islandId;
    }
    setLighthouseUrl(lighthouseUrl) {
        this.cleanStateAndConnections();
        this.wrtcHandler.setPeerServerUrl(lighthouseUrl);
        this.httpClient = new PeerHttpClient_1.PeerHttpClient(lighthouseUrl, () => this.wrtcHandler.config.connectionToken);
    }
    peerIdOrFail() {
        return this.wrtcHandler.peerId();
    }
    expireMessages() {
        const currentTimestamp = TimeKeeper_1.TimeKeeper.now();
        const keys = Object.keys(this.receivedPackets);
        keys.forEach((id) => {
            const received = this.receivedPackets[id];
            if (currentTimestamp - received.timestamp > received.expirationTime) {
                delete this.receivedPackets[id];
            }
        });
    }
    expirePeers() {
        const currentTimestamp = TimeKeeper_1.TimeKeeper.now();
        this.expireKnownPeers(currentTimestamp);
        this.expirePeerRelayData(currentTimestamp);
    }
    expirePeerRelayData(currentTimestamp) {
        Object.keys(this.peerRelayData).forEach((id) => {
            const connected = this.peerRelayData[id];
            // We expire peers suspensions
            Object.keys(connected.ownSuspendedRelays).forEach((srcId) => {
                if (connected.ownSuspendedRelays[srcId] <= currentTimestamp) {
                    delete connected.ownSuspendedRelays[srcId];
                }
            });
            Object.keys(connected.theirSuspendedRelays).forEach((srcId) => {
                if (connected.theirSuspendedRelays[srcId] <= currentTimestamp) {
                    delete connected.theirSuspendedRelays[srcId];
                }
            });
        });
    }
    expireKnownPeers(currentTimestamp) {
        Object.keys(this.knownPeers).forEach((id) => {
            const lastUpdate = this.knownPeers[id].lastUpdated;
            if (lastUpdate && currentTimestamp - lastUpdate > constants_1.PEER_CONSTANTS.KNOWN_PEERS_EXPIRE_TIME) {
                if (this.isConnectedTo(id)) {
                    this.disconnectFrom(id);
                }
                delete this.knownPeers[id];
            }
            else {
                // We expire reachable through data
                Object.keys(this.knownPeers[id].reachableThrough).forEach((relayId) => {
                    if (currentTimestamp - this.knownPeers[id].reachableThrough[relayId].timestamp >
                        constants_1.PEER_CONSTANTS.KNOWN_PEER_RELAY_EXPIRE_TIME) {
                        delete this.knownPeers[id].reachableThrough[relayId];
                    }
                });
            }
        });
    }
    disconnectFrom(peerId, removeListener = true) {
        this.wrtcHandler.disconnectFrom(peerId, removeListener);
        delete this.peerRelayData[peerId];
    }
    buildTopologyInfo() {
        return { connectedPeerIds: this.fullyConnectedPeerIds() };
    }
    buildPositionInfo() {
        if (this.config.positionConfig) {
            const positionInfo = {
                position: this.config.positionConfig.selfPosition(),
                // This is domain specific, but we still need it for finding crowded realms
                parcel: toParcel(this.config.positionConfig.selfPosition())
            };
            if (this.preferedIslandId) {
                positionInfo.preferedIslandId = this.preferedIslandId;
            }
            else if (this.preferedIslandId === null) {
                /** This is somewhat confusing. But is the easiest way to track this with only one attribute. See {@link Peer.setPreferedIslandId)}*/
                positionInfo.preferedIslandId = undefined;
            }
            return positionInfo;
        }
        else {
            return {};
        }
    }
    markReceived(packet) {
        this.receivedPackets[this.packetKey(packet)] = {
            timestamp: TimeKeeper_1.TimeKeeper.now(),
            expirationTime: this.getExpireTime(packet)
        };
    }
    packetKey(packet) {
        return `${packet.src}_${packet.instanceId}_${packet.sequenceId}`;
    }
    getExpireTime(packet) {
        return packet.expireTime > 0 ? packet.expireTime : this.config.messageExpirationTime;
    }
    awaitConnectionEstablished(timeoutMs = 10000) {
        return this.wrtcHandler.awaitConnectionEstablished();
    }
    async retryConnection() {
        var _a, _b;
        this.retryingConnection = true;
        const rooms = new Set(this.currentRooms);
        const { reconnectionAttempts, backoffMs } = this.config;
        for (let i = 1;; ++i) {
            if (this.disposed)
                return;
            this.log(types_1.LogLevel.DEBUG, `Connection attempt `, i);
            // To avoid synced retries, we use a random delay
            await util_2.delay(backoffMs + Math.floor(Math.random() * backoffMs));
            try {
                this.setLighthouseUrl(this.lighthouseUrl());
                await this.awaitConnectionEstablished();
                for (const room of rooms) {
                    await this.joinRoom(room);
                }
            }
            catch (e) {
                this.log(types_1.LogLevel.WARN, `Error while reconnecting (attempt ${i}) `, e);
                if (i >= reconnectionAttempts) {
                    this.log(types_1.LogLevel.ERROR, `Could not reconnect after ${reconnectionAttempts} failed attempts `, e);
                    (_b = (_a = this.config.eventsHandler).statusHandler) === null || _b === void 0 ? void 0 : _b.call(_a, 'reconnection-error');
                    break;
                }
            }
        }
        this.retryingConnection = false;
    }
    log(level, ...entries) {
        const currentLogLevelEnum = types_1.LogLevel[this.logLevel];
        if (level >= currentLogLevelEnum) {
            const levelText = types_1.LogLevel[level];
            console.log(`[PEER: ${this.peerId}][${levelText}]`, ...entries);
        }
    }
    set onIslandChange(onChange) {
        this.config.eventsHandler.onIslandChange = onChange;
    }
    get onIslandChange() {
        return this.config.eventsHandler.onIslandChange;
    }
    setIsland(islandId, peers) {
        var _a, _b;
        if (this.disposed)
            return;
        this.currentIslandId = islandId;
        // This two methods should be atomic. Ensure they are not called asynchronously
        this.setKnownPeers(peers);
        this.disconnectFromUnknownPeers();
        this.triggerUpdateNetwork(`changed to island ${islandId}`);
        (_b = (_a = this.config.eventsHandler).onIslandChange) === null || _b === void 0 ? void 0 : _b.call(_a, islandId, peers);
    }
    cleanStateAndConnections() {
        this.currentRooms.clear();
        this.knownPeers = {};
        this.wrtcHandler.cleanConnections();
    }
    async joinRoom(roomId) {
        this.currentRooms.add(roomId);
    }
    setKnownPeers(peers) {
        this.knownPeers = {};
        this.updateKnownPeers(peers);
    }
    disconnectFromUnknownPeers() {
        for (const peerId of this.wrtcHandler.connectedPeerIds()) {
            if (!(peerId in this.knownPeers)) {
                this.wrtcHandler.disconnectFrom(peerId);
            }
        }
    }
    updateKnownPeers(newPeers) {
        //We don't need to remove existing peers since they will eventually expire
        newPeers.forEach((peer) => {
            if (peer.id !== this.peerId) {
                this.addKnownPeerIfNotExists(peer);
                if (peer.position) {
                    this.setPeerPositionIfExistingPositionIsOld(peer.id, peer.position);
                }
            }
        });
    }
    addKnownPeerIfNotExists(peer) {
        if (!this.knownPeers[peer.id]) {
            this.knownPeers[peer.id] = Object.assign(Object.assign({}, peer), { subtypeData: {}, reachableThrough: {} });
        }
        return this.knownPeers[peer.id];
    }
    ensureAndUpdateKnownPeer(packet, connectedPeerId) {
        const minPeerData = { id: packet.src };
        this.addKnownPeerIfNotExists(minPeerData);
        this.knownPeers[packet.src].reachableThrough[connectedPeerId] = {
            id: connectedPeerId,
            hops: packet.hops + 1,
            timestamp: TimeKeeper_1.TimeKeeper.now()
        };
    }
    removeKnownPeer(peerId) {
        delete this.knownPeers[peerId];
    }
    calculateConnectionCandidates() {
        return Object.keys(this.knownPeers).filter((key) => !this.wrtcHandler.hasConnectionsFor(key));
    }
    async updateNetwork() {
        if (this.updatingNetwork || this.disposed) {
            return;
        }
        try {
            this.updatingNetwork = true;
            this.log(types_1.LogLevel.DEBUG, 'Updating network...');
            this.wrtcHandler.checkConnectionsSanity();
            let connectionCandidates = Object.values(this.knownPeers).filter((it) => this.isValidConnectionCandidate(it));
            let operation;
            while ((operation = this.calculateNextNetworkOperation(connectionCandidates))) {
                try {
                    connectionCandidates = await operation();
                }
                catch (e) {
                    // We may want to invalidate the operation or something to avoid repeating the same mistake
                    this.log(types_1.LogLevel.DEBUG, 'Error performing operation', operation, e);
                }
            }
        }
        finally {
            this.log(types_1.LogLevel.DEBUG, 'Network update finished');
            this.updatingNetwork = false;
        }
    }
    isValidConnectionCandidate(it) {
        var _a;
        return (!this.isConnectedTo(it.id) &&
            (!((_a = this.config.positionConfig) === null || _a === void 0 ? void 0 : _a.maxConnectionDistance) || this.isValidConnectionByDistance(it)));
    }
    isValidConnectionByDistance(peer) {
        const distance = this.distanceTo(peer.id);
        return typeof distance !== 'undefined' && distance <= this.config.positionConfig.maxConnectionDistance;
    }
    peerSortCriteria() {
        return (peer1, peer2) => {
            if (this.config.positionConfig) {
                // We prefer those peers that have position over those that don't
                if (peer1.position && !peer2.position)
                    return -1;
                if (peer2.position && !peer1.position)
                    return 1;
                if (peer1.position && peer2.position) {
                    const distanceDiff = this.distanceTo(peer1.id) - this.distanceTo(peer2.id);
                    // If the distance is the same, we randomize
                    return distanceDiff === 0 ? 0.5 - Math.random() : distanceDiff;
                }
            }
            // If none has position or if we don't, we randomize
            return 0.5 - Math.random();
        };
    }
    calculateNextNetworkOperation(connectionCandidates) {
        var _a;
        this.log(types_1.LogLevel.DEBUG, 'Calculating network operation with candidates', connectionCandidates);
        const peerSortCriteria = this.peerSortCriteria();
        const pickCandidates = (count) => {
            if (!this.config.positionConfig)
                return util_2.pickRandom(connectionCandidates, count);
            // We are going to be calculating the distance to each of the candidates. This could be costly, but since the state could have changed after every operation,
            // we need to ensure that the value is updated. If known peers is kept under maybe 2k elements, it should be no problem.
            return util_2.pickBy(connectionCandidates, count, peerSortCriteria);
        };
        const neededConnections = this.config.targetConnections - this.connectedCount();
        // If we need to establish new connections because we are below the target, we do that
        if (neededConnections > 0 && connectionCandidates.length > 0) {
            this.log(types_1.LogLevel.DEBUG, 'Establishing connections to reach target');
            return async () => {
                const [candidates, remaining] = pickCandidates(neededConnections);
                this.log(types_1.LogLevel.DEBUG, 'Picked connection candidates', candidates);
                await Promise.all(candidates.map((candidate) => this.connectTo(candidate).catch((e) => this.log(types_1.LogLevel.DEBUG, 'Error connecting to candidate', candidate, e))));
                return remaining;
            };
        }
        // If we are over the max amount of connections, we discard the "worst"
        const toDisconnect = this.connectedCount() - this.config.maxConnections;
        if (toDisconnect > 0) {
            this.log(types_1.LogLevel.DEBUG, 'Too many connections. Need to disconnect from: ' + toDisconnect);
            return async () => {
                Object.values(this.knownPeers)
                    .filter((peer) => this.isConnectedTo(peer.id))
                    // We sort the connected peer by the opposite criteria
                    .sort((peer1, peer2) => -peerSortCriteria(peer1, peer2))
                    .slice(0, toDisconnect)
                    .forEach((peer) => this.disconnectFrom(peer.id));
                return connectionCandidates;
            };
        }
        // If we have positionConfig, we try to find a better connection than any of the established
        if (this.config.positionConfig && connectionCandidates.length > 0) {
            // We find the worst distance of the current connections
            const worstPeer = this.getWorstConnectedPeerByDistance();
            const sortedCandidates = connectionCandidates.sort(peerSortCriteria);
            // We find the best candidate
            const bestCandidate = sortedCandidates.splice(0, 1)[0];
            if (bestCandidate) {
                const bestCandidateDistance = this.distanceTo(bestCandidate.id);
                if (typeof bestCandidateDistance !== 'undefined' && (!worstPeer || bestCandidateDistance < worstPeer[0])) {
                    // If the best candidate is better than the worst connection, we connect to that candidate.
                    // The next operation should handle the disconnection of the worst
                    this.log(types_1.LogLevel.DEBUG, 'Found a better candidate for connection: ', {
                        candidate: bestCandidate,
                        distance: bestCandidateDistance,
                        replacing: worstPeer
                    });
                    return async () => {
                        await this.connectTo(bestCandidate);
                        return sortedCandidates;
                    };
                }
            }
        }
        // We drop those connections too far away
        if ((_a = this.config.positionConfig) === null || _a === void 0 ? void 0 : _a.disconnectDistance) {
            const connectionsToDrop = this.wrtcHandler.connectedPeerIds().filter((it) => {
                const distance = this.distanceTo(it);
                // We need to check that we are actually connected to the peer, and also only disconnect to it if we know we are far away and we don't have any rooms in common
                return this.isConnectedTo(it) && distance && distance >= this.config.positionConfig.disconnectDistance;
            });
            if (connectionsToDrop.length > 0) {
                this.log(types_1.LogLevel.DEBUG, "Dropping connections because they are too far away and don't have rooms in common: ", connectionsToDrop);
                return async () => {
                    connectionsToDrop.forEach((it) => this.disconnectFrom(it));
                    return connectionCandidates;
                };
            }
        }
    }
    getWorstConnectedPeerByDistance() {
        return this.wrtcHandler.connectedPeerIds().reduce((currentWorst, peer) => {
            const currentDistance = this.distanceTo(peer);
            if (typeof currentDistance !== 'undefined') {
                return typeof currentWorst !== 'undefined' && currentWorst[0] >= currentDistance
                    ? currentWorst
                    : [currentDistance, peer];
            }
        }, undefined);
    }
    selfPosition() {
        var _a;
        return (_a = this.config.positionConfig) === null || _a === void 0 ? void 0 : _a.selfPosition();
    }
    distanceTo(peerId) {
        var _a, _b;
        const position = this.selfPosition();
        if (((_a = this.knownPeers[peerId]) === null || _a === void 0 ? void 0 : _a.position) && position) {
            return (_b = this.config.positionConfig) === null || _b === void 0 ? void 0 : _b.distance(position, this.knownPeers[peerId].position);
        }
    }
    connectedCount() {
        return this.wrtcHandler.connectedCount();
    }
    fullyConnectedPeerIds() {
        return this.wrtcHandler.fullyConnectedPeerIds();
    }
    async connectTo(known) {
        return await this.wrtcHandler.connectTo(known.id);
    }
    async leaveRoom(roomId) {
        this.currentRooms.delete(roomId);
    }
    beConnectedTo(peerId, timeout = 10000) {
        return this.wrtcHandler.beConnectedTo(peerId, timeout);
    }
    setPeerPosition(peerId, position) {
        if (this.knownPeers[peerId]) {
            this.knownPeers[peerId].position = position;
        }
    }
    setPeerPositionIfExistingPositionIsOld(peerId, position) {
        var _a;
        const timestamp = (_a = this.knownPeers[peerId]) === null || _a === void 0 ? void 0 : _a.timestamp;
        if (this.knownPeers[peerId] &&
            (!timestamp || TimeKeeper_1.TimeKeeper.now() - timestamp > constants_1.PEER_CONSTANTS.OLD_POSITION_THRESHOLD)) {
            // We assume that if we haven't received a position from a peer in 30 seconds,
            // then we can safely replace the position even if it is not the most updated
            this.knownPeers[peerId].position = position;
        }
    }
    isConnectedTo(peerId) {
        return this.wrtcHandler.isConnectedTo(peerId);
    }
    updateTimeStamp(peerId, subtype, timestamp, sequenceId) {
        var _a, _b, _c;
        const knownPeer = this.knownPeers[peerId];
        knownPeer.lastUpdated = TimeKeeper_1.TimeKeeper.now();
        knownPeer.timestamp = Math.max((_a = knownPeer.timestamp) !== null && _a !== void 0 ? _a : Number.MIN_SAFE_INTEGER, timestamp);
        if (subtype) {
            const lastData = knownPeer.subtypeData[subtype];
            knownPeer.subtypeData[subtype] = {
                lastTimestamp: Math.max((_b = lastData === null || lastData === void 0 ? void 0 : lastData.lastTimestamp) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER, timestamp),
                lastSequenceId: Math.max((_c = lastData === null || lastData === void 0 ? void 0 : lastData.lastSequenceId) !== null && _c !== void 0 ? _c : Number.MIN_SAFE_INTEGER, sequenceId)
            };
        }
    }
    handlePeerPacket(data, peerId) {
        if (this.disposed)
            return;
        try {
            const packet = peer_protobuf_1.Packet.decode(minimal_1.Reader.create(data));
            const alreadyReceived = !!this.receivedPackets[this.packetKey(packet)];
            this.ensureAndUpdateKnownPeer(packet, peerId);
            if (packet.discardOlderThan !== 0) {
                // If discardOlderThan is zero, then we don't need to store the package.
                // Same or older packages will be instantly discarded
                this.markReceived(packet);
            }
            const expired = this.checkExpired(packet);
            this.stats.countPacket(packet, data.length, 'received', this.getTagsForPacket(alreadyReceived, expired, packet));
            if (packet.hops >= 1) {
                this.countRelay(peerId, packet, expired, alreadyReceived);
            }
            if (!alreadyReceived && !expired) {
                this.processPacket(packet);
            }
            else {
                this.requestRelaySuspension(packet, peerId);
            }
        }
        catch (e) {
            this.log(types_1.LogLevel.WARN, 'Failed to process message from: ' + peerId, e);
            return;
        }
    }
    processPacket(packet) {
        this.updateTimeStamp(packet.src, packet.subtype, packet.timestamp, packet.sequenceId);
        packet.hops += 1;
        this.knownPeers[packet.src].hops = packet.hops;
        if (packet.hops < packet.ttl) {
            this.sendPacket(packet);
        }
        const messageData = packet.messageData;
        if (messageData) {
            if (this.isInRoom(messageData.room)) {
                this.callback(packet.src, messageData.room, this.decodePayload(messageData.payload, messageData.encoding), packet);
            }
        }
        const pingData = packet.pingData;
        if (pingData) {
            this.respondPing(pingData.pingId);
        }
        const pongData = packet.pongData;
        if (pongData) {
            this.processPong(packet.src, pongData.pingId);
        }
        const suspendRelayData = packet.suspendRelayData;
        if (suspendRelayData) {
            this.processSuspensionRequest(packet.src, suspendRelayData);
        }
    }
    getPeerRelayData(peerId) {
        if (!this.peerRelayData[peerId]) {
            this.peerRelayData[peerId] = {
                receivedRelayData: {},
                ownSuspendedRelays: {},
                theirSuspendedRelays: {},
                pendingSuspensionRequests: []
            };
        }
        return this.peerRelayData[peerId];
    }
    processSuspensionRequest(peerId, suspendRelayData) {
        if (this.wrtcHandler.hasConnectionsFor(peerId)) {
            const relayData = this.getPeerRelayData(peerId);
            suspendRelayData.relayedPeers.forEach((it) => (relayData.ownSuspendedRelays[it] = TimeKeeper_1.TimeKeeper.now() + suspendRelayData.durationMillis));
        }
    }
    requestRelaySuspension(packet, peerId) {
        const suspensionConfig = this.config.relaySuspensionConfig;
        if (suspensionConfig) {
            // First we update pending suspensions requests, adding the new one if needed
            this.consolidateSuspensionRequest(packet, peerId);
            const now = TimeKeeper_1.TimeKeeper.now();
            const relayData = this.getPeerRelayData(peerId);
            const lastSuspension = relayData.lastRelaySuspensionTimestamp;
            // We only send suspensions requests if more time than the configured interval has passed since last time
            if (lastSuspension && now - lastSuspension > suspensionConfig.relaySuspensionInterval) {
                const suspendRelayData = {
                    relayedPeers: relayData.pendingSuspensionRequests,
                    durationMillis: suspensionConfig.relaySuspensionDuration
                };
                this.log(types_1.LogLevel.DEBUG, `Requesting relay suspension to ${peerId}`, suspendRelayData);
                const packet = this.buildPacketWithData(messageTypes_1.SuspendRelayType, {
                    suspendRelayData
                });
                this.sendPacketToPeer(peerId, packet);
                suspendRelayData.relayedPeers.forEach((relayedPeerId) => {
                    relayData.theirSuspendedRelays[relayedPeerId] = TimeKeeper_1.TimeKeeper.now() + suspensionConfig.relaySuspensionDuration;
                });
                relayData.pendingSuspensionRequests = [];
                relayData.lastRelaySuspensionTimestamp = now;
            }
            else if (!lastSuspension) {
                // We skip the first suspension to give time to populate the structures
                relayData.lastRelaySuspensionTimestamp = now;
            }
        }
    }
    consolidateSuspensionRequest(packet, connectedPeerId) {
        const relayData = this.getPeerRelayData(connectedPeerId);
        if (relayData.pendingSuspensionRequests.includes(packet.src)) {
            // If there is already a pending suspension for this src through this connection, we don't do anything
            return;
        }
        this.log(types_1.LogLevel.DEBUG, `Consolidating suspension for ${packet.src}->${connectedPeerId}`);
        const now = TimeKeeper_1.TimeKeeper.now();
        // We get a list of through which connected peers is this src reachable and are not suspended
        const reachableThrough = Object.values(this.knownPeers[packet.src].reachableThrough).filter((it) => this.isConnectedTo(it.id) &&
            now - it.timestamp < constants_1.PEER_CONSTANTS.KNOWN_PEER_RELAY_EXPIRE_TIME &&
            !this.isRelayFromConnectionSuspended(it.id, packet.src, now));
        this.log(types_1.LogLevel.DEBUG, `${packet.src} is reachable through`, reachableThrough);
        // We only suspend if we will have at least 1 path of connection for this peer after suspensions
        if (reachableThrough.length > 1 || (reachableThrough.length === 1 && reachableThrough[0].id !== connectedPeerId)) {
            this.log(types_1.LogLevel.DEBUG, `Will add suspension for ${packet.src}->${connectedPeerId}`);
            relayData.pendingSuspensionRequests.push(packet.src);
        }
    }
    isRelayFromConnectionSuspended(connectedPeerId, srcId, now = TimeKeeper_1.TimeKeeper.now()) {
        const relayData = this.getPeerRelayData(connectedPeerId);
        return !!(relayData.pendingSuspensionRequests.includes(srcId) ||
            // Relays are suspended only if they are not expired
            (relayData.theirSuspendedRelays[srcId] && now < relayData.theirSuspendedRelays[srcId]));
    }
    isRelayToConnectionSuspended(connectedPeerId, srcId, now = TimeKeeper_1.TimeKeeper.now()) {
        const relayData = this.getPeerRelayData(connectedPeerId);
        return !!relayData.ownSuspendedRelays[srcId] && now < relayData.ownSuspendedRelays[srcId];
    }
    countRelay(peerId, packet, expired, alreadyReceived) {
        const relayData = this.getPeerRelayData(peerId);
        let receivedRelayData = relayData.receivedRelayData[packet.src];
        if (!receivedRelayData) {
            receivedRelayData = relayData.receivedRelayData[packet.src] = {
                hops: packet.hops,
                discarded: 0,
                total: 0
            };
        }
        else {
            receivedRelayData.hops = packet.hops;
        }
        receivedRelayData.total += 1;
        if (expired || alreadyReceived) {
            receivedRelayData.discarded += 1;
        }
    }
    getTagsForPacket(alreadyReceived, expired, packet) {
        const tags = [];
        if (alreadyReceived) {
            tags.push('duplicate');
        }
        if (expired) {
            tags.push('expired');
        }
        if (!packet.messageData || this.isInRoom(packet.messageData.room)) {
            tags.push('relevant');
        }
        return tags;
    }
    processPong(peerId, pingId) {
        const now = performance.now();
        const activePing = this.activePings[pingId];
        if (activePing && activePing.startTime) {
            const elapsed = now - activePing.startTime;
            const knownPeer = this.addKnownPeerIfNotExists({ id: peerId });
            knownPeer.latency = elapsed;
            activePing.results.push({ peerId, latency: elapsed });
        }
    }
    respondPing(pingId) {
        const pongData = { pingId };
        // TODO: Maybe we should add a destination and handle this message as unicast
        this.sendPacketWithData({ pongData }, messageTypes_1.PongMessageType, {
            expireTime: this.getPingTimeout()
        });
    }
    decodePayload(payload, encoding) {
        switch (encoding) {
            case peer_protobuf_1.PayloadEncoding.BYTES:
                return payload;
            case peer_protobuf_1.PayloadEncoding.STRING:
                return new TextDecoder('utf-8').decode(payload);
            case peer_protobuf_1.PayloadEncoding.JSON:
                return JSON.parse(new TextDecoder('utf-8').decode(payload));
        }
    }
    checkExpired(packet) {
        const discardedByOlderThan = this.isDiscardedByOlderThanReceivedPackages(packet);
        let discardedByExpireTime = false;
        const expireTime = this.getExpireTime(packet);
        if (this.knownPeers[packet.src].timestamp) {
            discardedByExpireTime = this.knownPeers[packet.src].timestamp - packet.timestamp > expireTime;
        }
        return discardedByOlderThan || discardedByExpireTime;
    }
    isDiscardedByOlderThanReceivedPackages(packet) {
        var _a;
        if (packet.discardOlderThan >= 0 && packet.subtype) {
            const subtypeData = (_a = this.knownPeers[packet.src]) === null || _a === void 0 ? void 0 : _a.subtypeData[packet.subtype];
            return (subtypeData &&
                subtypeData.lastTimestamp - packet.timestamp > packet.discardOlderThan &&
                subtypeData.lastSequenceId >= packet.sequenceId);
        }
        return false;
    }
    isInRoom(room) {
        return this.currentRooms.has(room);
    }
    generateMessageId() {
        this.currentMessageId += 1;
        return this.currentMessageId;
    }
    getEncodedPayload(payload) {
        if (payload instanceof Uint8Array) {
            return [peer_protobuf_1.PayloadEncoding.BYTES, payload];
        }
        else if (typeof payload === 'string') {
            return [peer_protobuf_1.PayloadEncoding.STRING, new TextEncoder().encode(payload)];
        }
        else {
            return [peer_protobuf_1.PayloadEncoding.JSON, new TextEncoder().encode(JSON.stringify(payload))];
        }
    }
    sendMessage(roomId, payload, type) {
        if (!this.isInRoom(roomId)) {
            return Promise.reject(new Error(`cannot send a message in a room not joined (${roomId})`));
        }
        const [encoding, encodedPayload] = this.getEncodedPayload(payload);
        const messageData = {
            room: roomId,
            encoding,
            payload: encodedPayload,
            dst: []
        };
        return this.sendPacketWithData({ messageData }, type);
    }
    sendPacketWithData(data, type, packetProperties = {}) {
        const packet = this.buildPacketWithData(type, data, packetProperties);
        this.sendPacket(packet);
        return Promise.resolve();
    }
    buildPacketWithData(type, data, packetProperties = {}) {
        var _a, _b;
        const sequenceId = this.generateMessageId();
        const packet = Object.assign(Object.assign({ sequenceId, instanceId: this.instanceId, subtype: type.name, expireTime: (_a = type.expirationTime) !== null && _a !== void 0 ? _a : -1, discardOlderThan: (_b = type.discardOlderThan) !== null && _b !== void 0 ? _b : -1, timestamp: TimeKeeper_1.TimeKeeper.now(), src: this.peerIdOrFail(), hops: 0, ttl: this.getTTL(sequenceId, type), receivedBy: [], optimistic: this.getOptimistic(sequenceId, type), pingData: undefined, pongData: undefined, suspendRelayData: undefined, messageData: undefined }, data), packetProperties);
        return packet;
    }
    async ping() {
        if (this.peerId) {
            const pingId = util_1.randomUint32();
            const pingFuture = fp_future_1.future();
            this.activePings[pingId] = {
                results: [],
                future: pingFuture
            };
            await this.sendPacketWithData({ pingData: { pingId } }, messageTypes_1.PingMessageType, {
                expireTime: this.getPingTimeout()
            });
            setTimeout(() => {
                const activePing = this.activePings[pingId];
                if (activePing) {
                    activePing.future.resolve(activePing.results);
                    delete this.activePings[pingId];
                }
            }, this.getPingTimeout());
            return await pingFuture;
        }
    }
    getPingTimeout() {
        var _a;
        return (_a = this.config.pingTimeout) !== null && _a !== void 0 ? _a : constants_1.PEER_CONSTANTS.DEFAULT_PING_TIMEOUT;
    }
    getTTL(index, type) {
        return typeof type.ttl !== 'undefined'
            ? typeof type.ttl === 'number'
                ? type.ttl
                : type.ttl(index, type)
            : constants_1.PEER_CONSTANTS.DEFAULT_TTL;
    }
    getOptimistic(index, type) {
        return typeof type.optimistic === 'boolean' ? type.optimistic : type.optimistic(index, type);
    }
    sendPacket(packet) {
        const id = this.peerIdOrFail();
        if (!packet.receivedBy.includes(id))
            packet.receivedBy.push(this.peerIdOrFail());
        const peersToSend = this.fullyConnectedPeerIds().filter((it) => !packet.receivedBy.includes(it) && (packet.hops === 0 || !this.isRelayToConnectionSuspended(it, packet.src)));
        if (packet.optimistic) {
            packet.receivedBy = [...packet.receivedBy, ...peersToSend];
        }
        // This is a little specific also, but is here in order to make the measurement as accurate as possible
        if (packet.pingData && packet.src === this.peerId) {
            const activePing = this.activePings[packet.pingData.pingId];
            if (activePing) {
                activePing.startTime = performance.now();
            }
        }
        peersToSend.forEach((peer) => this.sendPacketToPeer(peer, packet));
    }
    sendPacketToPeer(peer, packet) {
        if (this.isConnectedTo(peer)) {
            try {
                const data = peer_protobuf_1.Packet.encode(packet).finish();
                this.wrtcHandler.sendPacketToPeer(peer, data);
                this.stats.countPacket(packet, data.length, packet.hops === 0 ? 'sent' : 'relayed');
            }
            catch (e) {
                this.log(types_1.LogLevel.WARN, 'Error sending data to peer ' + peer, e);
            }
        }
    }
    lighthouseUrl() {
        return this.httpClient.lighthouseUrl;
    }
    // handles ws messages that are not handled by PeerWebRTCHandler
    handleServerMessage(message) {
        var _a, _b, _c, _d;
        switch (message.type) {
            case messages_1.PeerIncomingMessageType.CHANGE_ISLAND: {
                const { islandId, peers } = message.payload;
                this.setIsland(islandId, peers);
                break;
            }
            case messages_1.PeerIncomingMessageType.PEER_LEFT_ISLAND: {
                const { islandId, peer } = message.payload;
                if (islandId === this.currentIslandId) {
                    if (this.isConnectedTo(peer.id))
                        this.disconnectFrom(peer.id);
                    this.removeKnownPeer(peer.id);
                    this.triggerUpdateNetwork(`peer ${peer.id} joined island`);
                    (_b = (_a = this.config.eventsHandler).onPeerLeftIsland) === null || _b === void 0 ? void 0 : _b.call(_a, peer.id);
                }
                break;
            }
            case messages_1.PeerIncomingMessageType.PEER_JOINED_ISLAND: {
                const { islandId, peer } = message.payload;
                if (islandId === this.currentIslandId) {
                    this.addKnownPeerIfNotExists(peer);
                    this.triggerUpdateNetwork(`peer ${peer.id} joined island`);
                    (_d = (_c = this.config.eventsHandler).onPeerJoinedIsland) === null || _d === void 0 ? void 0 : _d.call(_c, peer.id);
                }
                break;
            }
        }
    }
    handleConnectionRequestRejected(peerId, reason) {
        if (reason === constants_1.ConnectionRejectReasons.MUST_BE_IN_SAME_DOMAIN_AND_LAYER) {
            this.removeKnownPeer(peerId);
        }
    }
    handlePeerConnectionLost(peerData) {
        delete this.peerRelayData[peerData.id];
        this.triggerUpdateNetwork(`peer ${peerData.id} disconnected`);
    }
    handlePeerConnectionEstablished(peerData) {
        if (this.connectedCount() >= this.config.maxConnections) {
            this.triggerUpdateNetwork(`peer ${peerData.id} connected`);
        }
    }
    triggerUpdateNetwork(event) {
        this.updateNetwork().catch((e) => {
            this.log(types_1.LogLevel.WARN, 'Error updating network after ' + event, e);
        });
    }
    validateHandshake(payload, peerId) {
        if (payload.protocolVersion !== PROTOCOL_VERSION) {
            return {
                ok: false,
                message: constants_1.ConnectionRejectReasons.INCOMPATIBLE_PROTOCOL_VERSION
            };
        }
        if (this.httpClient.lighthouseUrl !== payload.lighthouseUrl || this.currentIslandId !== payload.islandId) {
            return {
                ok: false,
                message: constants_1.ConnectionRejectReasons.MUST_BE_IN_SAME_DOMAIN_AND_LAYER
            };
        }
        return { ok: true };
    }
    validateReceivedOffer(payload, peerId) {
        if (this.connectedCount() >= this.config.maxConnections) {
            if (payload.position && this.selfPosition()) {
                const knownPeer = this.addKnownPeerIfNotExists({ id: peerId });
                knownPeer.lastUpdated = TimeKeeper_1.TimeKeeper.now();
                knownPeer.position = payload.position;
                const worstPeer = this.getWorstConnectedPeerByDistance();
                if (worstPeer && this.distanceTo(peerId) > worstPeer[0]) {
                    // If the new peer distance is worse than the worst peer distance we have, we reject it
                    return {
                        ok: false,
                        message: constants_1.ConnectionRejectReasons.TOO_MANY_CONNECTIONS
                    };
                }
                else {
                    // We are going to be over connected so we trigger a delayed network update to ensure we keep below the max connections
                    setTimeout(() => this.updateNetwork(), constants_1.PEER_CONSTANTS.OVERCONNECTED_NETWORK_UPDATE_DELAY);
                    // This continues below
                }
            }
            else {
                // We also reject if there is no position configuration
                return {
                    ok: false,
                    message: constants_1.ConnectionRejectReasons.TOO_MANY_CONNECTIONS
                };
            }
        }
        return { ok: true };
    }
    async dispose() {
        this.disposed = true;
        clearTimeout(this.updateNetworkTimeoutId);
        clearTimeout(this.expireTimeoutId);
        clearTimeout(this.pingTimeoutId);
        this.cleanStateAndConnections();
        const wrtcDispose = this.wrtcHandler.dispose();
        this.stats.dispose();
        return wrtcDispose;
    }
}
exports.Peer = Peer;
//# sourceMappingURL=Peer.js.map