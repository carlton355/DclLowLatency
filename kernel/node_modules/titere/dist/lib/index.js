"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const util = require("util");
const puppeteer = require("puppeteer");
const downloadChromium_1 = require("./downloadChromium");
const mochaBrowserShim_1 = require("./mochaBrowserShim");
const fs_1 = require("fs");
async function configureViewport(width, height, page) {
    if (!width && !height)
        return page;
    let viewport = page.viewport();
    width && (viewport.width = width);
    height && (viewport.height = height);
    await page.setViewport(viewport);
    return page;
}
function handleConsole(msg) {
    new Promise(async (resolve, reject) => {
        try {
            let args = await Promise.all(msg.args().map($ => $.jsonValue()));
            // process stdout stub
            let isStdout = args[0] === 'stdout:';
            if (isStdout) {
                // tslint:disable-next-line
                args = args.slice(1);
            }
            // tslint:disable-next-line
            let text = util.format(...args);
            !isStdout && (text += '\n');
            process.stdout.write(text);
        }
        catch (e) {
            console.error(e);
            reject(e);
        }
        resolve(1);
    }).catch(_ => process.stdout.write('Error printing error: ' + msg.text()));
}
function prepareUrl(filePath) {
    if (/^[a-zA-Z]+:\/\//.test(filePath)) {
        // path is URL
        return filePath;
    }
    // local path
    let resolvedPath = path.resolve(filePath);
    return `file://${resolvedPath}`;
}
/**
 * Runs client-side mocha tests in the command line through Puppeteer.
 *
 * @returns A Promise for the test results.
 */
async function run({ file, reporter, timeout, width, height, args, executablePath, visible }) {
    // validate options
    if (!file) {
        throw new Error('Test page path is required.');
    }
    let theTimeout = timeout || 60000;
    const url = prepareUrl(file);
    const options = {
        ignoreHTTPSErrors: true,
        headless: false,
        args,
        dumpio: true,
        executablePath
    };
    if (!options.executablePath) {
        executablePath = await downloadChromium_1.getLocalPath();
    }
    const browser = await puppeteer.launch(options);
    const page = await browser.newPage();
    await configureViewport(width || 800, height || 600, page);
    page.on('console', handleConsole);
    page.on('dialog', dialog => dialog.dismiss());
    // tslint:disable-next-line:no-console
    page.on('pageerror', err => console.error(err));
    await page.evaluateOnNewDocument(mochaBrowserShim_1.initMocha, reporter);
    await page.goto(url);
    await page.waitForFunction(() => window['__mochaResult__'], { timeout: theTimeout });
    const result = await page.evaluate(() => window['__mochaResult__']);
    await browser.close();
    return result;
}
exports.run = run;
function serveIndex(compiledTestsLocation) {
    return serveRaw(`<script src="${compiledTestsLocation}"></script>`);
}
exports.serveIndex = serveIndex;
function sourceUrl(file) {
    return JSON.stringify(fs_1.readFileSync(file) + '\n//# sourceURL=file');
}
function serveRaw(html) {
    return function (req, res) {
        res.writeHead(200, 'OK', {
            'Content-Type': 'text/html'
        });
        res.write(`<!DOCTYPE html>
      <html>

      <head>
        <title>Mocha Tests</title>
        <meta charset="utf-8">
        <style>
          ${fs_1.readFileSync(require.resolve('mocha/mocha.css')).toJSON()}
        </style>
      </head>

      <body>
        <div id="mocha"></div>
        <script>
          eval(${sourceUrl(require.resolve('mocha/mocha.js'))})
        </script>
        <script>mocha.setup('bdd');</script>
        ${html}
      </body>

      </html>
    `);
        res.end();
    };
}
exports.serveRaw = serveRaw;
//# sourceMappingURL=index.js.map